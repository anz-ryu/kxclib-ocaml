// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("rescript/lib/js/sys.js");
var Caml = require("rescript/lib/js/caml.js");
var Bytes = require("rescript/lib/js/bytes.js");
var Curry = require("rescript/lib/js/curry.js");
var Int32 = require("rescript/lib/js/int32.js");
var Int64 = require("rescript/lib/js/int64.js");
var Scanf = require("rescript/lib/js/scanf.js");
var Uchar = require("rescript/lib/js/uchar.js");
var Format = require("rescript/lib/js/format.js");
var Random = require("rescript/lib/js/random.js");
var Stream = require("rescript/lib/js/stream.js");
var $$String = require("rescript/lib/js/string.js");
var Hashtbl = require("rescript/lib/js/hashtbl.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Caml_sys = require("rescript/lib/js/caml_sys.js");
var Js_types = require("rescript/lib/js/js_types.js");
var Printexc = require("rescript/lib/js/printexc.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Caml_bytes = require("rescript/lib/js/caml_bytes.js");
var Caml_int32 = require("rescript/lib/js/caml_int32.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_format = require("rescript/lib/js/caml_format.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_string = require("rescript/lib/js/caml_string.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function _flip(f, a, b) {
  return Curry._2(f, b, a);
}

function _obj_make(param) {
  return {};
}

function _obj_set(o, k, v) {
  return (function(o, k, v){o[k] = v})(o, k, v);
}

function _obj_get(o, k) {
  return (function(o, k){return o[k]})(o, k);
}

function _stringify(x) {
  return (function(x){return ''+x;})(x);
}

var BaseCompInternals = {
  _flip: _flip,
  _obj_make: _obj_make,
  _obj_set: _obj_set,
  _obj_get: _obj_get,
  _stringify: _stringify
};

function empty(param) {
  return /* Nil */0;
}

function $$return(x, param) {
  return /* Cons */{
          _0: x,
          _1: empty
        };
}

function cons(x, next, param) {
  return /* Cons */{
          _0: x,
          _1: next
        };
}

function append(seq1, seq2, param) {
  var match = Curry._1(seq1, undefined);
  if (!match) {
    return Curry._1(seq2, undefined);
  }
  var next = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return append(next, seq2, param);
            })
        };
}

function map(f, seq, param) {
  var match = Curry._1(seq, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var next = match._1;
  return /* Cons */{
          _0: Curry._1(f, match._0),
          _1: (function (param) {
              return map(f, next, param);
            })
        };
}

function filter_map(f, _seq, _param) {
  while(true) {
    var seq = _seq;
    var match = Curry._1(seq, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var next = match._1;
    var y = Curry._1(f, match._0);
    if (y !== undefined) {
      return /* Cons */{
              _0: Caml_option.valFromOption(y),
              _1: (function(next){
              return function (param) {
                return filter_map(f, next, param);
              }
              }(next))
            };
    }
    _param = undefined;
    _seq = next;
    continue ;
  };
}

function filter(f, _seq, _param) {
  while(true) {
    var seq = _seq;
    var match = Curry._1(seq, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var next = match._1;
    var x = match._0;
    if (Curry._1(f, x)) {
      return /* Cons */{
              _0: x,
              _1: (function(next){
              return function (param) {
                return filter(f, next, param);
              }
              }(next))
            };
    }
    _param = undefined;
    _seq = next;
    continue ;
  };
}

function flat_map(f, seq, param) {
  var match = Curry._1(seq, undefined);
  if (match) {
    return flat_map_app(f, Curry._1(f, match._0), match._1, undefined);
  } else {
    return /* Nil */0;
  }
}

function flat_map_app(f, seq, tail, param) {
  var match = Curry._1(seq, undefined);
  if (!match) {
    return flat_map(f, tail, undefined);
  }
  var next = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return flat_map_app(f, next, tail, param);
            })
        };
}

function fold_left(f, acc, seq) {
  var _acc = acc;
  var _seq = seq;
  while(true) {
    var seq$1 = _seq;
    var acc$1 = _acc;
    var match = Curry._1(seq$1, undefined);
    if (!match) {
      return acc$1;
    }
    var acc$2 = Curry._2(f, acc$1, match._0);
    _seq = match._1;
    _acc = acc$2;
    continue ;
  };
}

function iter(f, seq) {
  var _seq = seq;
  while(true) {
    var seq$1 = _seq;
    var match = Curry._1(seq$1, undefined);
    if (!match) {
      return ;
    }
    Curry._1(f, match._0);
    _seq = match._1;
    continue ;
  };
}

function unfold(f, u, param) {
  var match = Curry._1(f, u);
  if (match === undefined) {
    return /* Nil */0;
  }
  var u$p = match[1];
  return /* Cons */{
          _0: match[0],
          _1: (function (param) {
              return unfold(f, u$p, param);
            })
        };
}

var Seq = {
  empty: empty,
  $$return: $$return,
  cons: cons,
  append: append,
  map: map,
  filter_map: filter_map,
  filter: filter,
  flat_map: flat_map,
  flat_map_app: flat_map_app,
  fold_left: fold_left,
  iter: iter,
  unfold: unfold
};

function or_exn(e, x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw e;
}

function or_not_found(o) {
  return or_exn({
              RE_EXN_ID: "Not_found"
            }, o);
}

function some(v) {
  return Caml_option.some(v);
}

function value(o, $$default) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  } else {
    return $$default;
  }
}

function get(v) {
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  } else {
    return Pervasives.invalid_arg("option is None");
  }
}

function bind(o, f) {
  if (o !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(o));
  }
  
}

function join(o) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  }
  
}

function map$1(f, o) {
  if (o !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(o)));
  }
  
}

function fold(none, some, v) {
  if (v !== undefined) {
    return Curry._1(some, Caml_option.valFromOption(v));
  } else {
    return none;
  }
}

function iter$1(f, v) {
  if (v !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(v));
  }
  
}

function is_none(param) {
  return param === undefined;
}

function is_some(param) {
  return param !== undefined;
}

function equal(eq, o0, o1) {
  if (o0 !== undefined) {
    if (o1 !== undefined) {
      return Curry._2(eq, Caml_option.valFromOption(o0), Caml_option.valFromOption(o1));
    } else {
      return false;
    }
  } else {
    return o1 === undefined;
  }
}

function compare(cmp, o0, o1) {
  if (o0 !== undefined) {
    if (o1 !== undefined) {
      return Curry._2(cmp, Caml_option.valFromOption(o0), Caml_option.valFromOption(o1));
    } else {
      return 1;
    }
  } else if (o1 !== undefined) {
    return -1;
  } else {
    return 0;
  }
}

function to_result(none, v) {
  if (v !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(v)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: none
          };
  }
}

function to_list(v) {
  if (v !== undefined) {
    return {
            hd: Caml_option.valFromOption(v),
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

function to_seq(v) {
  if (v === undefined) {
    return empty;
  }
  var partial_arg = Caml_option.valFromOption(v);
  return function (param) {
    return /* Cons */{
            _0: partial_arg,
            _1: empty
          };
  };
}

var $$Option = {
  or_exn: or_exn,
  or_not_found: or_not_found,
  none: undefined,
  some: some,
  value: value,
  get: get,
  bind: bind,
  join: join,
  map: map$1,
  fold: fold,
  iter: iter$1,
  is_none: is_none,
  is_some: is_some,
  equal: equal,
  compare: compare,
  to_result: to_result,
  to_list: to_list,
  to_seq: to_seq
};

var B;

var Imported = {};

function length(arr) {
  return arr.length;
}

function get$1(arr) {
  return function (param) {
    return Belt_Array.getExn(arr, param);
  };
}

function set(arr) {
  return function (param, param$1) {
    return Belt_Array.setExn(arr, param, param$1);
  };
}

function make(n, x) {
  var arr = new Array(n);
  arr.fill(x);
  return arr;
}

var create = make;

function unsafe_get(arr) {
  return function (param) {
    return Belt_Array.getExn(arr, param);
  };
}

function unsafe_set(arr) {
  return function (param, param$1) {
    return Belt_Array.setExn(arr, param, param$1);
  };
}

function unsafe_fill(arr, ofs, len, v) {
  arr.fill(v, ofs, ofs + len | 0);
  
}

function append_prim(a1, a2) {
  return a1.concat(a2);
}

function unsafe_sub(arr, ofs, len) {
  var arr$p = new Array(len);
  for(var i = ofs; i < len; ++i){
    Caml_array.set(arr$p, i, Caml_array.get(arr, i));
  }
  return arr$p;
}

function unsafe_blit(src, src_ofs, dst, dst_ofs, len) {
  for(var i = 0; i < len; ++i){
    Caml_array.set(dst, dst_ofs + i | 0, Caml_array.get(src, src_ofs + i | 0));
  }
  
}

var Internals = {
  unsafe_get: unsafe_get,
  unsafe_set: unsafe_set,
  unsafe_fill: unsafe_fill,
  append_prim: append_prim,
  unsafe_sub: unsafe_sub,
  unsafe_blit: unsafe_blit
};

function init(l, f) {
  if (l === 0) {
    return [];
  }
  if (l < 0) {
    return Pervasives.invalid_arg("Array.init");
  }
  var res = make(l, Curry._1(f, 0));
  for(var i = 1; i < l; ++i){
    Belt_Array.setExn(res, i, Curry._1(f, i));
  }
  return res;
}

function copy(a) {
  var l = a.length;
  if (l === 0) {
    return [];
  } else {
    return unsafe_sub(a, 0, l);
  }
}

function append$1(a1, a2) {
  var l1 = a1.length;
  if (l1 === 0) {
    return copy(a2);
  } else if (a2.length === 0) {
    return unsafe_sub(a1, 0, l1);
  } else {
    return a1.concat(a2);
  }
}

function sub(a, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    return Pervasives.invalid_arg("Array.sub");
  } else {
    return unsafe_sub(a, ofs, len);
  }
}

function fill(a, ofs, len, v) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    return Pervasives.invalid_arg("Array.fill");
  } else {
    return unsafe_fill(a, ofs, len, v);
  }
}

function blit(a1, ofs1, a2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (a1.length - len | 0) || ofs2 < 0 || ofs2 > (a2.length - len | 0)) {
    return Pervasives.invalid_arg("Array.blit");
  } else {
    return unsafe_blit(a1, ofs1, a2, ofs2, len);
  }
}

function iter$2(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._1(f, Belt_Array.getExn(a, i));
  }
  
}

function iter2(f, a, b) {
  if (a.length !== b.length) {
    return Pervasives.invalid_arg("Array.iter2: arrays must have the same length");
  }
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, Belt_Array.getExn(a, i), Belt_Array.getExn(b, i));
  }
  
}

function map$2(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = make(l, Curry._1(f, Belt_Array.getExn(a, 0)));
  for(var i = 1; i < l; ++i){
    Belt_Array.setExn(r, i, Curry._1(f, Belt_Array.getExn(a, i)));
  }
  return r;
}

function map2(f, a, b) {
  var la = a.length;
  var lb = b.length;
  if (la !== lb) {
    return Pervasives.invalid_arg("Array.map2: arrays must have the same length");
  }
  if (la === 0) {
    return [];
  }
  var r = make(la, Curry._2(f, Belt_Array.getExn(a, 0), Belt_Array.getExn(b, 0)));
  for(var i = 1; i < la; ++i){
    Belt_Array.setExn(r, i, Curry._2(f, Belt_Array.getExn(a, i), Belt_Array.getExn(b, i)));
  }
  return r;
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, i, Belt_Array.getExn(a, i));
  }
  
}

function mapi(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = make(l, Curry._2(f, 0, Belt_Array.getExn(a, 0)));
  for(var i = 1; i < l; ++i){
    Belt_Array.setExn(r, i, Curry._2(f, i, Belt_Array.getExn(a, i)));
  }
  return r;
}

function to_list$1(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: Belt_Array.getExn(a, i),
      tl: res
    };
    _i = i - 1 | 0;
    continue ;
  };
}

function list_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = accu + 1 | 0;
    continue ;
  };
}

function of_list(l) {
  if (!l) {
    return [];
  }
  var a = make(list_length(0, l), l.hd);
  var _i = 1;
  var _param = l.tl;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return a;
    }
    Belt_Array.setExn(a, i, param.hd);
    _param = param.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function fold_left$1(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = Curry._2(f, r, Belt_Array.getExn(a, i));
  }
  return r;
}

function fold_right(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = Curry._2(f, Belt_Array.getExn(a, i), r);
  }
  return r;
}

function exists(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, Belt_Array.getExn(a, i))) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, Belt_Array.getExn(a, i))) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all2(p, l1, l2) {
  var n1 = l1.length;
  var n2 = l2.length;
  if (n1 !== n2) {
    return Pervasives.invalid_arg("Array.for_all2");
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n1) {
      return true;
    }
    if (!Curry._2(p, Belt_Array.getExn(l1, i), Belt_Array.getExn(l2, i))) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function exists2(p, l1, l2) {
  var n1 = l1.length;
  var n2 = l2.length;
  if (n1 !== n2) {
    return Pervasives.invalid_arg("Array.exists2");
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n1) {
      return false;
    }
    if (Curry._2(p, Belt_Array.getExn(l1, i), Belt_Array.getExn(l2, i))) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function mem(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Caml_obj.caml_equal(Belt_Array.getExn(a, i), x)) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function memq(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (x === Belt_Array.getExn(a, i)) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

var Bottom = /* @__PURE__ */Caml_exceptions.create("Kxclib.Kxclib_comp_re.Array.Bottom");

function sort(cmp, a) {
  var maxson = function (l, i) {
    var i31 = ((i + i | 0) + i | 0) + 1 | 0;
    var x = i31;
    if ((i31 + 2 | 0) < l) {
      if (Curry._2(cmp, Belt_Array.getExn(a, i31), Belt_Array.getExn(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (Curry._2(cmp, Belt_Array.getExn(a, x), Belt_Array.getExn(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    }
    if ((i31 + 1 | 0) < l && Curry._2(cmp, Belt_Array.getExn(a, i31), Belt_Array.getExn(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    }
    if (i31 < l) {
      return i31;
    }
    throw {
          RE_EXN_ID: Bottom,
          _1: i,
          Error: new Error()
        };
  };
  var trickle = function (l, i, e) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        if (Curry._2(cmp, Belt_Array.getExn(a, j), e) <= 0) {
          return Belt_Array.setExn(a, i$1, e);
        }
        Belt_Array.setExn(a, i$1, Belt_Array.getExn(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_i){
      var i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.RE_EXN_ID === Bottom) {
        return Belt_Array.setExn(a, i$2._1, e);
      }
      throw i$2;
    }
  };
  var bubble = function (l, i) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        Belt_Array.setExn(a, i$1, Belt_Array.getExn(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_i){
      var i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.RE_EXN_ID === Bottom) {
        return i$2._1;
      }
      throw i$2;
    }
  };
  var trickleup = function (_i, e) {
    while(true) {
      var i = _i;
      var father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "kxclib_comp_re.ml",
                365,
                4
              ],
              Error: new Error()
            };
      }
      if (Curry._2(cmp, Belt_Array.getExn(a, father), e) >= 0) {
        return Belt_Array.setExn(a, i, e);
      }
      Belt_Array.setExn(a, i, Belt_Array.getExn(a, father));
      if (father <= 0) {
        return Belt_Array.setExn(a, 0, e);
      }
      _i = father;
      continue ;
    };
  };
  var l = a.length;
  for(var i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i){
    trickle(l, i, Belt_Array.getExn(a, i));
  }
  for(var i$1 = l - 1 | 0; i$1 >= 2; --i$1){
    var e = Belt_Array.getExn(a, i$1);
    Belt_Array.setExn(a, i$1, Belt_Array.getExn(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l <= 1) {
    return ;
  }
  var e$1 = Belt_Array.getExn(a, 1);
  Belt_Array.setExn(a, 1, Belt_Array.getExn(a, 0));
  return Belt_Array.setExn(a, 0, e$1);
}

function stable_sort(cmp, a) {
  var merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    var src1r = src1ofs + src1len | 0;
    var src2r = src2ofs + src2len | 0;
    var _i1 = src1ofs;
    var _s1 = Belt_Array.getExn(a, src1ofs);
    var _i2 = src2ofs;
    var _s2 = Belt_Array.getExn(src2, src2ofs);
    var _d = dstofs;
    while(true) {
      var d = _d;
      var s2 = _s2;
      var i2 = _i2;
      var s1 = _s1;
      var i1 = _i1;
      if (Curry._2(cmp, s1, s2) <= 0) {
        Belt_Array.setExn(dst, d, s1);
        var i1$1 = i1 + 1 | 0;
        if (i1$1 >= src1r) {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
        _d = d + 1 | 0;
        _s1 = Belt_Array.getExn(a, i1$1);
        _i1 = i1$1;
        continue ;
      }
      Belt_Array.setExn(dst, d, s2);
      var i2$1 = i2 + 1 | 0;
      if (i2$1 >= src2r) {
        return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
      }
      _d = d + 1 | 0;
      _s2 = Belt_Array.getExn(src2, i2$1);
      _i2 = i2$1;
      continue ;
    };
  };
  var isortto = function (srcofs, dst, dstofs, len) {
    for(var i = 0; i < len; ++i){
      var e = Belt_Array.getExn(a, srcofs + i | 0);
      var j = (dstofs + i | 0) - 1 | 0;
      while(j >= dstofs && Curry._2(cmp, Belt_Array.getExn(dst, j), e) > 0) {
        Belt_Array.setExn(dst, j + 1 | 0, Belt_Array.getExn(dst, j));
        j = j - 1 | 0;
      };
      Belt_Array.setExn(dst, j + 1 | 0, e);
    }
    
  };
  var sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    }
    var l1 = len / 2 | 0;
    var l2 = len - l1 | 0;
    sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
    sortto(srcofs, a, srcofs + l2 | 0, l1);
    return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
  };
  var l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  }
  var l1 = l / 2 | 0;
  var l2 = l - l1 | 0;
  var t = make(l2, Belt_Array.getExn(a, 0));
  sortto(l1, t, 0, l2);
  sortto(0, a, l2, l1);
  return merge(l2, l1, t, 0, l2, a, 0);
}

function to_seq$1(a) {
  var aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */0;
    }
    var x = Belt_Array.getExn(a, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(a) {
  var aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */0;
    }
    var x = Belt_Array.getExn(a, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_rev_list(l) {
  if (!l) {
    return [];
  }
  var len = list_length(0, l);
  var a = make(len, l.hd);
  var _i = len - 2 | 0;
  var _param = l.tl;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return a;
    }
    Belt_Array.setExn(a, i, param.hd);
    _param = param.tl;
    _i = i - 1 | 0;
    continue ;
  };
}

function of_seq(i) {
  return of_rev_list(fold_left((function (acc, x) {
                    return {
                            hd: x,
                            tl: acc
                          };
                  }), /* [] */0, i));
}

var $$Array$1 = {
  B: B,
  Imported: Imported,
  length: length,
  get: get$1,
  set: set,
  make: make,
  create: create,
  Internals: Internals,
  init: init,
  copy: copy,
  append: append$1,
  sub: sub,
  fill: fill,
  blit: blit,
  iter: iter$2,
  iter2: iter2,
  map: map$2,
  map2: map2,
  iteri: iteri,
  mapi: mapi,
  to_list: to_list$1,
  list_length: list_length,
  of_list: of_list,
  fold_left: fold_left$1,
  fold_right: fold_right,
  exists: exists,
  for_all: for_all,
  for_all2: for_all2,
  exists2: exists2,
  mem: mem,
  memq: memq,
  Bottom: Bottom,
  sort: sort,
  cutoff: 5,
  stable_sort: stable_sort,
  fast_sort: stable_sort,
  to_seq: to_seq$1,
  to_seqi: to_seqi,
  of_rev_list: of_rev_list,
  of_seq: of_seq
};

function ok(v) {
  return {
          TAG: /* Ok */0,
          _0: v
        };
}

function error(e) {
  return {
          TAG: /* Error */1,
          _0: e
        };
}

function value$1(r, $$default) {
  if (r.TAG === /* Ok */0) {
    return r._0;
  } else {
    return $$default;
  }
}

function get_ok(v) {
  if (v.TAG === /* Ok */0) {
    return v._0;
  } else {
    return Pervasives.invalid_arg("result is Error _");
  }
}

function get_error(e) {
  if (e.TAG === /* Ok */0) {
    return Pervasives.invalid_arg("result is Ok _");
  } else {
    return e._0;
  }
}

function bind$1(r, f) {
  if (r.TAG === /* Ok */0) {
    return Curry._1(f, r._0);
  } else {
    return r;
  }
}

function join$1(r) {
  if (r.TAG === /* Ok */0) {
    return r._0;
  } else {
    return r;
  }
}

function map$3(f, v) {
  if (v.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(f, v._0)
          };
  } else {
    return v;
  }
}

function map_error(f, e) {
  if (e.TAG === /* Ok */0) {
    return e;
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._1(f, e._0)
          };
  }
}

function fold$1(ok, error, v) {
  if (v.TAG === /* Ok */0) {
    return Curry._1(ok, v._0);
  } else {
    return Curry._1(error, v._0);
  }
}

function iter$3(f, v) {
  if (v.TAG === /* Ok */0) {
    return Curry._1(f, v._0);
  }
  
}

function iter_error(f, e) {
  if (e.TAG === /* Ok */0) {
    return ;
  } else {
    return Curry._1(f, e._0);
  }
}

function is_ok(param) {
  if (param.TAG === /* Ok */0) {
    return true;
  } else {
    return false;
  }
}

function is_error(param) {
  if (param.TAG === /* Ok */0) {
    return false;
  } else {
    return true;
  }
}

function equal$1(ok, error, r0, r1) {
  if (r0.TAG === /* Ok */0) {
    if (r1.TAG === /* Ok */0) {
      return Curry._2(ok, r0._0, r1._0);
    } else {
      return false;
    }
  } else if (r1.TAG === /* Ok */0) {
    return false;
  } else {
    return Curry._2(error, r0._0, r1._0);
  }
}

function compare$1(ok, error, r0, r1) {
  if (r0.TAG === /* Ok */0) {
    if (r1.TAG === /* Ok */0) {
      return Curry._2(ok, r0._0, r1._0);
    } else {
      return -1;
    }
  } else if (r1.TAG === /* Ok */0) {
    return 1;
  } else {
    return Curry._2(error, r0._0, r1._0);
  }
}

function to_option(v) {
  if (v.TAG === /* Ok */0) {
    return Caml_option.some(v._0);
  }
  
}

function to_list$2(v) {
  if (v.TAG === /* Ok */0) {
    return {
            hd: v._0,
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

function to_seq$2(v) {
  if (v.TAG !== /* Ok */0) {
    return empty;
  }
  var partial_arg = v._0;
  return function (param) {
    return /* Cons */{
            _0: partial_arg,
            _1: empty
          };
  };
}

var Result = {
  ok: ok,
  error: error,
  value: value$1,
  get_ok: get_ok,
  get_error: get_error,
  bind: bind$1,
  join: join$1,
  map: map$3,
  map_error: map_error,
  fold: fold$1,
  iter: iter$3,
  iter_error: iter_error,
  is_ok: is_ok,
  is_error: is_error,
  equal: equal$1,
  compare: compare$1,
  to_option: to_option,
  to_list: to_list$2,
  to_seq: to_seq$2
};

var B$1;

var length$1 = Belt_List.length;

function hd(l) {
  return or_exn({
              RE_EXN_ID: "Failure",
              _1: "hd"
            }, Belt_List.head(l));
}

function tl(l) {
  return or_exn({
              RE_EXN_ID: "Failure",
              _1: "tl"
            }, Belt_List.tail(l));
}

var nth_opt = Belt_List.get;

function nth(l, n) {
  return or_exn({
              RE_EXN_ID: "Invalid_argument",
              _1: "List.nth"
            }, Belt_List.get(l, n));
}

var rev_append = Belt_List.reverseConcat;

var rev = Belt_List.reverse;

var init$1 = Belt_List.makeBy;

var flatten = Belt_List.flatten;

function map$4(f, l) {
  return Belt_List.map(l, f);
}

function mapi$1(f, l) {
  return Belt_List.mapWithIndex(l, f);
}

function rev_map(f, l) {
  return Belt_List.mapReverse(l, f);
}

function iter$4(f, l) {
  return Belt_List.forEach(l, f);
}

function iteri$1(f, l) {
  return Belt_List.forEachWithIndex(l, f);
}

function fold_left$2(f, accu, l) {
  return Belt_List.reduce(l, accu, f);
}

function fold_right$1(f, l, accu) {
  return Belt_List.reduceReverse(l, accu, (function (param, param$1) {
                return Curry._2(f, param$1, param);
              }));
}

function map2$1(f, l1, l2) {
  return Belt_List.zipBy(l1, l2, f);
}

function rev_map2(f, l1, l2) {
  return Belt_List.mapReverse2(l1, l2, f);
}

function iter2$1(f, l1, l2) {
  return Belt_List.forEach2(l1, l2, f);
}

function for_all$1(p, l) {
  return Belt_List.every(l, p);
}

function exists$1(p, l) {
  return Belt_List.some(l, p);
}

function for_all2$1(p, l1, l2) {
  return Belt_List.every2(l1, l2, p);
}

function exists2$1(p, l1, l2) {
  return Belt_List.some2(l1, l2, p);
}

function mem$1(x, l) {
  return Belt_List.some(l, (function (param) {
                return Caml_obj.caml_equal(x, param);
              }));
}

function memq$1(x, l) {
  return Belt_List.some(l, (function (param) {
                return x === param;
              }));
}

function assoc_opt(k, l) {
  return Belt_List.getAssoc(l, k, Caml_obj.caml_equal);
}

function assq_opt(k, l) {
  return Belt_List.getAssoc(l, k, (function (prim0, prim1) {
                return prim0 === prim1;
              }));
}

function assoc(k, l) {
  var o = assoc_opt(k, l);
  return or_exn({
              RE_EXN_ID: "Not_found"
            }, o);
}

function assq(k, l) {
  var o = assq_opt(k, l);
  return or_exn({
              RE_EXN_ID: "Not_found"
            }, o);
}

function mem_assoc(x, l) {
  return Belt_List.hasAssoc(l, x, Caml_obj.caml_equal);
}

function mem_assq(x, l) {
  return Belt_List.hasAssoc(l, x, (function (prim0, prim1) {
                return prim0 === prim1;
              }));
}

function remove_assoc(x, l) {
  return Belt_List.removeAssoc(l, x, Caml_obj.caml_equal);
}

function remove_assq(x, l) {
  return Belt_List.removeAssoc(l, x, (function (prim0, prim1) {
                return prim0 === prim1;
              }));
}

function find_opt(p, l) {
  return Belt_List.getBy(l, p);
}

function find(p, l) {
  var o = Belt_List.getBy(l, p);
  return or_exn({
              RE_EXN_ID: "Not_found"
            }, o);
}

function find_map(f, l) {
  return bind(Belt_List.getBy(l, (function (x) {
                    return Curry._1(f, x) !== undefined;
                  })), f);
}

function find_all(p, l) {
  return Belt_List.keep(l, p);
}

function filteri(p, l) {
  return Belt_List.keepWithIndex(l, (function (param, param$1) {
                return Curry._2(p, param$1, param);
              }));
}

function filter_map$1(f, l) {
  return Belt_List.keepMap(l, f);
}

function concat_map(f, l) {
  var _acc = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return Belt_List.reverse(acc);
    }
    var xs = Curry._1(f, param.hd);
    _param = param.tl;
    _acc = Belt_List.reverseConcat(xs, acc);
    continue ;
  };
}

function fold_left_map(f, accu, l) {
  var _accu = accu;
  var _l_accu = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var l_accu = _l_accu;
    var accu$1 = _accu;
    if (!param) {
      return [
              accu$1,
              Belt_List.reverse(l_accu)
            ];
    }
    var match = Curry._2(f, accu$1, param.hd);
    _param = param.tl;
    _l_accu = {
      hd: match[1],
      tl: l_accu
    };
    _accu = match[0];
    continue ;
  };
}

function partition(p, l) {
  return Belt_List.partition(l, p);
}

var split = Belt_List.unzip;

var combine = Belt_List.zip;

function merge(cmp, l1, l2) {
  if (!l1) {
    return l2;
  }
  if (!l2) {
    return l1;
  }
  var h2 = l2.hd;
  var h1 = l1.hd;
  if (Curry._2(cmp, h1, h2) <= 0) {
    return {
            hd: h1,
            tl: merge(cmp, l1.tl, l2)
          };
  } else {
    return {
            hd: h2,
            tl: merge(cmp, l1, l2.tl)
          };
  }
}

function stable_sort$1(cmp, l) {
  return Belt_List.sort(l, cmp);
}

function compare$2(cmp, l1, l2) {
  return Belt_List.cmp(l1, l2, cmp);
}

function equal$2(eq, l1, l2) {
  return Belt_List.eq(l1, l2, eq);
}

function to_seq$3(l) {
  var aux = function (l, param) {
    if (!l) {
      return /* Nil */0;
    }
    var tail = l.tl;
    return /* Cons */{
            _0: l.hd,
            _1: (function (param) {
                return aux(tail, param);
              })
          };
  };
  return function (param) {
    return aux(l, param);
  };
}

function of_seq$1(seq) {
  var direct = function (depth, seq) {
    if (depth === 0) {
      return Belt_List.reverse(fold_left((function (acc, x) {
                        return {
                                hd: x,
                                tl: acc
                              };
                      }), /* [] */0, seq));
    }
    var match = Curry._1(seq, undefined);
    if (match) {
      return {
              hd: match._0,
              tl: direct(depth - 1 | 0, match._1)
            };
    } else {
      return /* [] */0;
    }
  };
  return direct(500, seq);
}

var List = {
  B: B$1,
  length: length$1,
  hd: hd,
  tl: tl,
  nth_opt: nth_opt,
  nth: nth,
  append: Pervasives.$at,
  rev_append: rev_append,
  rev: rev,
  init: init$1,
  flatten: flatten,
  concat: flatten,
  map: map$4,
  mapi: mapi$1,
  rev_map: rev_map,
  iter: iter$4,
  iteri: iteri$1,
  fold_left: fold_left$2,
  fold_right: fold_right$1,
  map2: map2$1,
  rev_map2: rev_map2,
  iter2: iter2$1,
  for_all: for_all$1,
  exists: exists$1,
  for_all2: for_all2$1,
  exists2: exists2$1,
  mem: mem$1,
  memq: memq$1,
  assoc_opt: assoc_opt,
  assq_opt: assq_opt,
  assoc: assoc,
  assq: assq,
  mem_assoc: mem_assoc,
  mem_assq: mem_assq,
  remove_assoc: remove_assoc,
  remove_assq: remove_assq,
  find_opt: find_opt,
  find: find,
  find_map: find_map,
  find_all: find_all,
  filter: find_all,
  filteri: filteri,
  filter_map: filter_map$1,
  concat_map: concat_map,
  fold_left_map: fold_left_map,
  partition: partition,
  split: split,
  combine: combine,
  merge: merge,
  stable_sort: stable_sort$1,
  sort: stable_sort$1,
  fast_sort: stable_sort$1,
  compare: compare$2,
  equal: equal$2,
  to_seq: to_seq$3,
  of_seq: of_seq$1
};

function add_seq(tbl, i) {
  return iter((function (param) {
                return Hashtbl.add(tbl, param[0], param[1]);
              }), i);
}

function replace_seq(tbl, i) {
  return iter((function (param) {
                return Hashtbl.replace(tbl, param[0], param[1]);
              }), i);
}

function of_seq$2(i) {
  var tbl = Hashtbl.create(undefined, 16);
  replace_seq(tbl, i);
  return tbl;
}

function to_seq$4(tbl) {
  return to_seq$3(Hashtbl.fold((function (k, v, acc) {
                    return {
                            hd: [
                              k,
                              v
                            ],
                            tl: acc
                          };
                  }), tbl, /* [] */0));
}

function to_seq_keys(m) {
  var partial_arg = to_seq$4(m);
  return function (param) {
    return map((function (prim) {
                  return prim[0];
                }), partial_arg, param);
  };
}

function to_seq_values(m) {
  var partial_arg = to_seq$4(m);
  return function (param) {
    return map((function (prim) {
                  return prim[1];
                }), partial_arg, param);
  };
}

var Hashtbl$1 = {
  create: Hashtbl.create,
  clear: Hashtbl.clear,
  reset: Hashtbl.reset,
  copy: Hashtbl.copy,
  add: Hashtbl.add,
  find: Hashtbl.find,
  find_opt: Hashtbl.find_opt,
  find_all: Hashtbl.find_all,
  mem: Hashtbl.mem,
  remove: Hashtbl.remove,
  replace: Hashtbl.replace,
  iter: Hashtbl.iter,
  filter_map_inplace: Hashtbl.filter_map_inplace,
  fold: Hashtbl.fold,
  length: Hashtbl.length,
  randomize: Hashtbl.randomize,
  is_randomized: Hashtbl.is_randomized,
  stats: Hashtbl.stats,
  Make: Hashtbl.Make,
  MakeSeeded: Hashtbl.MakeSeeded,
  hash: Hashtbl.hash,
  seeded_hash: Hashtbl.seeded_hash,
  hash_param: Hashtbl.hash_param,
  seeded_hash_param: Hashtbl.seeded_hash_param,
  add_seq: add_seq,
  replace_seq: replace_seq,
  of_seq: of_seq$2,
  to_seq: to_seq$4,
  to_seq_keys: to_seq_keys,
  to_seq_values: to_seq_values
};

var get_uint8 = Caml_bytes.get;

function to_seq$5(s) {
  var aux = function (i, param) {
    if (i === s.length) {
      return /* Nil */0;
    }
    var x = Caml_bytes.get(s, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi$1(s) {
  var aux = function (i, param) {
    if (i === s.length) {
      return /* Nil */0;
    }
    var x = Caml_bytes.get(s, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_seq$3(i) {
  var n = {
    contents: 0
  };
  var buf = {
    contents: Bytes.make(256, /* '\000' */0)
  };
  var resize = function (param) {
    var new_len = Caml.caml_int_min((buf.contents.length << 1), Sys.max_string_length);
    if (buf.contents.length === new_len) {
      Pervasives.failwith("Bytes.of_seq: cannot grow bytes");
    }
    var new_buf = Bytes.make(new_len, /* '\000' */0);
    Bytes.blit(buf.contents, 0, new_buf, 0, n.contents);
    buf.contents = new_buf;
    
  };
  iter((function (c) {
          if (n.contents === buf.contents.length) {
            resize(undefined);
          }
          Caml_bytes.set(buf.contents, n.contents, c);
          n.contents = n.contents + 1 | 0;
          
        }), i);
  return Bytes.sub(buf.contents, 0, n.contents);
}

var Bytes$1 = {
  make: Bytes.make,
  init: Bytes.init,
  empty: Bytes.empty,
  copy: Bytes.copy,
  of_string: Bytes.of_string,
  to_string: Bytes.to_string,
  sub: Bytes.sub,
  sub_string: Bytes.sub_string,
  extend: Bytes.extend,
  fill: Bytes.fill,
  blit: Bytes.blit,
  blit_string: Bytes.blit_string,
  concat: Bytes.concat,
  cat: Bytes.cat,
  iter: Bytes.iter,
  iteri: Bytes.iteri,
  map: Bytes.map,
  mapi: Bytes.mapi,
  trim: Bytes.trim,
  escaped: Bytes.escaped,
  index: Bytes.index,
  index_opt: Bytes.index_opt,
  rindex: Bytes.rindex,
  rindex_opt: Bytes.rindex_opt,
  index_from: Bytes.index_from,
  index_from_opt: Bytes.index_from_opt,
  rindex_from: Bytes.rindex_from,
  rindex_from_opt: Bytes.rindex_from_opt,
  contains: Bytes.contains,
  contains_from: Bytes.contains_from,
  rcontains_from: Bytes.rcontains_from,
  uppercase: Bytes.uppercase,
  lowercase: Bytes.lowercase,
  capitalize: Bytes.capitalize,
  uncapitalize: Bytes.uncapitalize,
  uppercase_ascii: Bytes.uppercase_ascii,
  lowercase_ascii: Bytes.lowercase_ascii,
  capitalize_ascii: Bytes.capitalize_ascii,
  uncapitalize_ascii: Bytes.uncapitalize_ascii,
  compare: Bytes.compare,
  equal: Bytes.equal,
  unsafe_to_string: Bytes.unsafe_to_string,
  unsafe_of_string: Bytes.unsafe_of_string,
  get_uint8: get_uint8,
  to_seq: to_seq$5,
  to_seqi: to_seqi$1,
  of_seq: of_seq$3
};

var B$2;

function to_seq$6(s) {
  return to_seq$5(Bytes.unsafe_of_string(s));
}

function to_seqi$2(s) {
  return to_seqi$1(Bytes.unsafe_of_string(s));
}

function of_seq$4(g) {
  return Bytes.unsafe_to_string(of_seq$3(g));
}

var $$String$1 = {
  make: $$String.make,
  init: $$String.init,
  sub: $$String.sub,
  blit: $$String.blit,
  concat: $$String.concat,
  iter: $$String.iter,
  iteri: $$String.iteri,
  map: $$String.map,
  mapi: $$String.mapi,
  trim: $$String.trim,
  escaped: $$String.escaped,
  index: $$String.index,
  index_opt: $$String.index_opt,
  rindex: $$String.rindex,
  rindex_opt: $$String.rindex_opt,
  index_from: $$String.index_from,
  index_from_opt: $$String.index_from_opt,
  rindex_from: $$String.rindex_from,
  rindex_from_opt: $$String.rindex_from_opt,
  contains: $$String.contains,
  contains_from: $$String.contains_from,
  rcontains_from: $$String.rcontains_from,
  uppercase: $$String.uppercase,
  lowercase: $$String.lowercase,
  capitalize: $$String.capitalize,
  uncapitalize: $$String.uncapitalize,
  uppercase_ascii: $$String.uppercase_ascii,
  lowercase_ascii: $$String.lowercase_ascii,
  capitalize_ascii: $$String.capitalize_ascii,
  uncapitalize_ascii: $$String.uncapitalize_ascii,
  compare: $$String.compare,
  equal: $$String.equal,
  split_on_char: $$String.split_on_char,
  B: B$2,
  bos: Bytes.unsafe_of_string,
  bts: Bytes.unsafe_to_string,
  to_seq: to_seq$6,
  to_seqi: to_seqi$2,
  of_seq: of_seq$4
};

function neg(x) {
  return -x | 0;
}

function add(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function sub$1(prim0, prim1) {
  return prim0 - prim1 | 0;
}

function mul(prim0, prim1) {
  return Math.imul(prim0, prim1);
}

var div = Caml_int32.div;

var rem = Caml_int32.mod_;

function succ(prim) {
  return prim + 1 | 0;
}

function pred(prim) {
  return prim - 1 | 0;
}

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

var Imported$1 = {};

var max_int = Number.MAX_SAFE_INTEGER;

var min_int = Number.MIN_SAFE_INTEGER;

var Int = {
  zero: 0,
  one: 1,
  minus_one: -1,
  neg: neg,
  add: add,
  sub: sub$1,
  mul: mul,
  div: div,
  rem: rem,
  succ: succ,
  pred: pred,
  abs: abs,
  Imported: Imported$1,
  max_int: max_int,
  min_int: min_int
};

var Imported$2 = {};

function ceil(prim) {
  return Math.ceil(prim);
}

function floor(prim) {
  return Math.floor(prim);
}

function is_integer(prim) {
  return Number.isInteger(prim);
}

function to_int(x) {
  return x;
}

var Float = {
  Imported: Imported$2,
  ceil: ceil,
  floor: floor,
  is_integer: is_integer,
  to_int: to_int
};

function create$1(n) {
  var n$1 = n < 1 ? 1 : n;
  var n$2 = n$1 > Sys.max_string_length ? Sys.max_string_length : n$1;
  var s = Caml_bytes.caml_create_bytes(n$2);
  return {
          buffer: s,
          position: 0,
          length: n$2,
          initial_buffer: s
        };
}

function contents(b) {
  return Bytes.sub_string(b.buffer, 0, b.position);
}

function to_bytes(b) {
  return Bytes.sub(b.buffer, 0, b.position);
}

function sub$2(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.position - len | 0)) {
    return Pervasives.invalid_arg("Buffer.sub");
  } else {
    return Bytes.sub_string(b.buffer, ofs, len);
  }
}

function blit$1(src, srcoff, dst, dstoff, len) {
  if (len < 0 || srcoff < 0 || srcoff > (src.position - len | 0) || dstoff < 0 || dstoff > (dst.length - len | 0)) {
    return Pervasives.invalid_arg("Buffer.blit");
  } else {
    return Caml_bytes.caml_blit_bytes(src.buffer, srcoff, dst, dstoff, len);
  }
}

function nth$1(b, ofs) {
  if (ofs < 0 || ofs >= b.position) {
    return Pervasives.invalid_arg("Buffer.nth");
  } else {
    return b.buffer[ofs];
  }
}

function length$2(b) {
  return b.position;
}

function clear(b) {
  b.position = 0;
  
}

function reset(b) {
  b.position = 0;
  b.buffer = b.initial_buffer;
  b.length = b.buffer.length;
  
}

function resize(b, more) {
  var old_pos = b.position;
  var old_len = b.length;
  var new_len = old_len;
  while((old_pos + more | 0) > new_len) {
    new_len = (new_len << 1);
  };
  if (new_len > Sys.max_string_length) {
    if ((old_pos + more | 0) <= Sys.max_string_length) {
      new_len = Sys.max_string_length;
    } else {
      Pervasives.failwith("Buffer.add: cannot grow buffer");
    }
  }
  var new_buffer = Caml_bytes.caml_create_bytes(new_len);
  Bytes.blit(b.buffer, 0, new_buffer, 0, b.position);
  b.buffer = new_buffer;
  b.length = new_len;
  if ((b.position + more | 0) > b.length) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            802,
            2
          ],
          Error: new Error()
        };
  }
  if ((old_pos + more | 0) > b.length) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            803,
            2
          ],
          Error: new Error()
        };
  }
  
}

function add_char(b, c) {
  var pos = b.position;
  if (pos >= b.length) {
    resize(b, 1);
  }
  b.buffer[pos] = c;
  b.position = pos + 1 | 0;
  
}

function add_utf_8_uchar(b, u) {
  var u$1 = Uchar.to_int(u);
  if (u$1 < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            847,
            19
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 127) {
    return add_char(b, u$1);
  }
  if (u$1 <= 2047) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = 192 | (u$1 >>> 6);
    b.buffer[pos + 1 | 0] = 128 | u$1 & 63;
    b.position = pos + 2 | 0;
    return ;
  }
  if (u$1 <= 65535) {
    var pos$1 = b.position;
    if ((pos$1 + 3 | 0) > b.length) {
      resize(b, 3);
    }
    b.buffer[pos$1] = 224 | (u$1 >>> 12);
    b.buffer[pos$1 + 1 | 0] = 128 | (u$1 >>> 6) & 63;
    b.buffer[pos$1 + 2 | 0] = 128 | u$1 & 63;
    b.position = pos$1 + 3 | 0;
    return ;
  }
  if (u$1 <= 1114111) {
    var pos$2 = b.position;
    if ((pos$2 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$2] = 240 | (u$1 >>> 18);
    b.buffer[pos$2 + 1 | 0] = 128 | (u$1 >>> 12) & 63;
    b.buffer[pos$2 + 2 | 0] = 128 | (u$1 >>> 6) & 63;
    b.buffer[pos$2 + 3 | 0] = 128 | u$1 & 63;
    b.position = pos$2 + 4 | 0;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "kxclib_comp_re.ml",
          880,
          8
        ],
        Error: new Error()
      };
}

function add_utf_16be_uchar(b, u) {
  var u$1 = Uchar.to_int(u);
  if (u$1 < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            883,
            19
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 65535) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = (u$1 >>> 8);
    b.buffer[pos + 1 | 0] = u$1 & 255;
    b.position = pos + 2 | 0;
    return ;
  }
  if (u$1 <= 1114111) {
    var u$p = u$1 - 65536 | 0;
    var hi = 55296 | (u$p >>> 10);
    var lo = 56320 | u$p & 1023;
    var pos$1 = b.position;
    if ((pos$1 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$1] = (hi >>> 8);
    b.buffer[pos$1 + 1 | 0] = hi & 255;
    b.buffer[pos$1 + 2 | 0] = (lo >>> 8);
    b.buffer[pos$1 + 3 | 0] = lo & 255;
    b.position = pos$1 + 4 | 0;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "kxclib_comp_re.ml",
          901,
          8
        ],
        Error: new Error()
      };
}

function add_utf_16le_uchar(b, u) {
  var u$1 = Uchar.to_int(u);
  if (u$1 < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            904,
            19
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 65535) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = u$1 & 255;
    b.buffer[pos + 1 | 0] = (u$1 >>> 8);
    b.position = pos + 2 | 0;
    return ;
  }
  if (u$1 <= 1114111) {
    var u$p = u$1 - 65536 | 0;
    var hi = 55296 | (u$p >>> 10);
    var lo = 56320 | u$p & 1023;
    var pos$1 = b.position;
    if ((pos$1 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$1] = hi & 255;
    b.buffer[pos$1 + 1 | 0] = (hi >>> 8);
    b.buffer[pos$1 + 2 | 0] = lo & 255;
    b.buffer[pos$1 + 3 | 0] = (lo >>> 8);
    b.position = pos$1 + 4 | 0;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "kxclib_comp_re.ml",
          922,
          8
        ],
        Error: new Error()
      };
}

function add_substring(b, s, offset, len) {
  if (offset < 0 || len < 0 || offset > (s.length - len | 0)) {
    Pervasives.invalid_arg("Buffer.add_substring/add_subbytes");
  }
  var new_position = b.position + len | 0;
  if (new_position > b.length) {
    resize(b, len);
  }
  Caml_bytes.caml_blit_bytes(Bytes.of_string(s), offset, b.buffer, b.position, len);
  b.position = new_position;
  
}

function add_subbytes(b, s, offset, len) {
  return add_substring(b, Bytes.unsafe_to_string(s), offset, len);
}

function add_string(b, s) {
  var len = s.length;
  var new_position = b.position + len | 0;
  if (new_position > b.length) {
    resize(b, len);
  }
  Caml_bytes.caml_blit_bytes(Bytes.of_string(s), 0, b.buffer, b.position, len);
  b.position = new_position;
  
}

function add_bytes(b, s) {
  return add_string(b, Bytes.unsafe_to_string(s));
}

function add_buffer(b, bs) {
  return add_subbytes(b, bs.buffer, 0, bs.position);
}

function really_input_up_to(ic, buf, ofs, len) {
  var _already_read = 0;
  var _ofs = ofs;
  var _to_read = len;
  while(true) {
    var to_read = _to_read;
    var ofs$1 = _ofs;
    var already_read = _already_read;
    if (to_read === 0) {
      return already_read;
    }
    var r = Pervasives.input(ic, buf, ofs$1, to_read);
    if (r === 0) {
      return already_read;
    }
    var already_read$1 = already_read + r | 0;
    var ofs$2 = ofs$1 + r | 0;
    var to_read$1 = to_read - r | 0;
    _to_read = to_read$1;
    _ofs = ofs$2;
    _already_read = already_read$1;
    continue ;
  };
}

function unsafe_add_channel_up_to(b, ic, len) {
  if ((b.position + len | 0) > b.length) {
    resize(b, len);
  }
  var n = really_input_up_to(ic, b.buffer, b.position, len);
  if ((b.position + n | 0) > b.length) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            972,
            2
          ],
          Error: new Error()
        };
  }
  b.position = b.position + n | 0;
  return n;
}

function add_channel(b, ic, len) {
  if (len < 0 || len > Sys.max_string_length) {
    Pervasives.invalid_arg("Buffer.add_channel");
  }
  var n = unsafe_add_channel_up_to(b, ic, len);
  if (n < len) {
    throw {
          RE_EXN_ID: "End_of_file",
          Error: new Error()
        };
  }
  
}

function output_buffer(oc, b) {
  return Pervasives.output(oc, b.buffer, 0, b.position);
}

function closing(param) {
  if (param === 40) {
    return /* ')' */41;
  }
  if (param === 123) {
    return /* '}' */125;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "kxclib_comp_re.ml",
          991,
          9
        ],
        Error: new Error()
      };
}

function advance_to_closing(opening, closing, k, s, start) {
  var _k = k;
  var _i = start;
  var lim = s.length;
  while(true) {
    var i = _i;
    var k$1 = _k;
    if (i >= lim) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    if (Caml_string.get(s, i) === opening) {
      _i = i + 1 | 0;
      _k = k$1 + 1 | 0;
      continue ;
    }
    if (Caml_string.get(s, i) === closing) {
      if (k$1 === 0) {
        return i;
      }
      _i = i + 1 | 0;
      _k = k$1 - 1 | 0;
      continue ;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function advance_to_non_alpha(s, start) {
  var _i = start;
  var lim = s.length;
  while(true) {
    var i = _i;
    if (i >= lim) {
      return lim;
    }
    var match = Caml_string.get(s, i);
    if (match >= 91) {
      if (match >= 97) {
        if (match >= 123) {
          return i;
        }
        
      } else if (match !== 95) {
        return i;
      }
      
    } else if (match >= 58) {
      if (match < 65) {
        return i;
      }
      
    } else if (match < 48) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_ident(s, start, lim) {
  if (start >= lim) {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  var c = Caml_string.get(s, start);
  if (c !== 40 && c !== 123) {
    var stop = advance_to_non_alpha(s, start + 1 | 0);
    return [
            $$String.sub(s, start, stop - start | 0),
            stop
          ];
  }
  var new_start = start + 1 | 0;
  var stop$1 = advance_to_closing(c, closing(c), 0, s, new_start);
  return [
          $$String.sub(s, new_start, (stop$1 - start | 0) - 1 | 0),
          stop$1 + 1 | 0
        ];
}

function add_substitute(b, f, s) {
  var lim = s.length;
  var _previous = /* ' ' */32;
  var _i = 0;
  while(true) {
    var i = _i;
    var previous = _previous;
    if (i >= lim) {
      if (previous === /* '\\' */92) {
        return add_char(b, previous);
      } else {
        return ;
      }
    }
    var current = Caml_string.get(s, i);
    if (current !== 36) {
      if (previous === /* '\\' */92) {
        add_char(b, /* '\\' */92);
        add_char(b, current);
        _i = i + 1 | 0;
        _previous = /* ' ' */32;
        continue ;
      }
      if (current !== 92) {
        add_char(b, current);
        _i = i + 1 | 0;
        _previous = current;
        continue ;
      }
      _i = i + 1 | 0;
      _previous = current;
      continue ;
    }
    if (previous === /* '\\' */92) {
      add_char(b, current);
      _i = i + 1 | 0;
      _previous = /* ' ' */32;
      continue ;
    }
    var j = i + 1 | 0;
    var match = find_ident(s, j, lim);
    add_string(b, Curry._1(f, match[0]));
    _i = match[1];
    _previous = /* ' ' */32;
    continue ;
  };
}

function truncate(b, len) {
  if (len < 0 || len > b.position) {
    return Pervasives.invalid_arg("Buffer.truncate");
  } else {
    b.position = len;
    return ;
  }
}

function to_seq$7(b) {
  var aux = function (i, param) {
    if (i >= b.position) {
      return /* Nil */0;
    }
    var x = b.buffer[i];
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi$3(b) {
  var aux = function (i, param) {
    if (i >= b.position) {
      return /* Nil */0;
    }
    var x = b.buffer[i];
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function add_seq$1(b, seq) {
  return iter((function (param) {
                return add_char(b, param);
              }), seq);
}

function of_seq$5(i) {
  var b = create$1(32);
  iter((function (param) {
          return add_char(b, param);
        }), i);
  return b;
}

function add_int8(b, x) {
  var new_position = b.position + 1 | 0;
  if (new_position > b.length) {
    resize(b, 1);
  }
  b.buffer[b.position] = x;
  b.position = new_position;
  
}

var $$Buffer = {
  create: create$1,
  contents: contents,
  to_bytes: to_bytes,
  sub: sub$2,
  blit: blit$1,
  nth: nth$1,
  length: length$2,
  clear: clear,
  reset: reset,
  resize: resize,
  add_char: add_char,
  add_utf_8_uchar: add_utf_8_uchar,
  add_utf_16be_uchar: add_utf_16be_uchar,
  add_utf_16le_uchar: add_utf_16le_uchar,
  add_substring: add_substring,
  add_subbytes: add_subbytes,
  add_string: add_string,
  add_bytes: add_bytes,
  add_buffer: add_buffer,
  really_input_up_to: really_input_up_to,
  unsafe_add_channel_up_to: unsafe_add_channel_up_to,
  add_channel: add_channel,
  output_buffer: output_buffer,
  closing: closing,
  advance_to_closing: advance_to_closing,
  advance_to_non_alpha: advance_to_non_alpha,
  find_ident: find_ident,
  add_substitute: add_substitute,
  truncate: truncate,
  to_seq: to_seq$7,
  to_seqi: to_seqi$3,
  add_seq: add_seq$1,
  of_seq: of_seq$5,
  add_int8: add_int8,
  add_uint8: add_int8
};

function to_xjv(param) {
  if (typeof param !== "object") {
    return null;
  }
  var variant = param.NAME;
  if (variant === "arr") {
    return map$2(to_xjv, of_list(param.VAL));
  }
  if (variant === "num") {
    return param.VAL;
  }
  if (variant !== "obj") {
    return param.VAL;
  }
  var o = {};
  Belt_List.forEach(param.VAL, (function (param) {
          return _obj_set(o, param[0], to_xjv(param[1]));
        }));
  return o;
}

function of_xjv(x) {
  var x$1 = Js_types.classify(x);
  if (typeof x$1 === "number") {
    switch (x$1) {
      case /* JSFalse */0 :
          return {
                  NAME: "bool",
                  VAL: false
                };
      case /* JSTrue */1 :
          return {
                  NAME: "bool",
                  VAL: true
                };
      case /* JSNull */2 :
          return "null";
      case /* JSUndefined */3 :
          return Pervasives.invalid_arg("of_xjv: 'undefined' not expected");
      
    }
  } else {
    switch (x$1.TAG | 0) {
      case /* JSNumber */0 :
          return {
                  NAME: "num",
                  VAL: x$1._0
                };
      case /* JSString */1 :
          return {
                  NAME: "str",
                  VAL: x$1._0
                };
      case /* JSObject */3 :
          var obj = x$1._0;
          if (Array.isArray(obj)) {
            var xs = to_list$1(map$2(of_xjv, obj));
            return {
                    NAME: "arr",
                    VAL: xs
                  };
          }
          var keys = Object.keys(obj);
          var fs = to_list$1(map$2((function (k) {
                      return [
                              k,
                              of_xjv(_obj_get(obj, k))
                            ];
                    }), keys));
          return {
                  NAME: "obj",
                  VAL: fs
                };
      case /* JSFunction */2 :
      case /* JSSymbol */4 :
          return Pervasives.invalid_arg("of_xjv: function not expected: " + _stringify(x$1._0));
      
    }
  }
}

function json_of_xjv(xjv) {
  return JSON.stringify(xjv);
}

function json_of_jv(jv) {
  return JSON.stringify(to_xjv(jv));
}

function xjv_of_json_exn(json) {
  return JSON.parse(json);
}

function xjv_of_json(json) {
  try {
    return Caml_option.some(JSON.parse(json));
  }
  catch (exn){
    return ;
  }
}

function jv_of_json_exn(json) {
  return of_xjv(JSON.parse(json));
}

function jv_of_json(json) {
  return map$1(of_xjv, xjv_of_json(json));
}

var obj00 = {
  NAME: "obj",
  VAL: /* [] */0
};

var obj01 = {
  NAME: "obj",
  VAL: {
    hd: [
      "name",
      {
        NAME: "str",
        VAL: "James Smith"
      }
    ],
    tl: {
      hd: [
        "age",
        {
          NAME: "num",
          VAL: 12
        }
      ],
      tl: /* [] */0
    }
  }
};

var obj02 = {
  NAME: "obj",
  VAL: {
    hd: [
      "name",
      {
        NAME: "str",
        VAL: "James Smith"
      }
    ],
    tl: {
      hd: [
        "age",
        {
          NAME: "num",
          VAL: 12
        }
      ],
      tl: {
        hd: [
          "spouse",
          "null"
        ],
        tl: {
          hd: [
            "parents",
            {
              NAME: "arr",
              VAL: {
                hd: {
                  NAME: "str",
                  VAL: "Amy Smith"
                },
                tl: {
                  hd: {
                    NAME: "str",
                    VAL: "Bob Smith"
                  },
                  tl: /* [] */0
                }
              }
            }
          ],
          tl: /* [] */0
        }
      }
    }
  }
};

var xjv_conv_obj00 = to_xjv(obj00);

var xjv_conv_obj01 = to_xjv(obj01);

var xjv_conv_obj02 = to_xjv(obj02);

var TestSamples = {
  obj00: obj00,
  obj01: obj01,
  obj02: obj02,
  xjv_conv_obj00: xjv_conv_obj00,
  xjv_conv_obj01: xjv_conv_obj01,
  xjv_conv_obj02: xjv_conv_obj02
};

var Json_ext = {
  to_xjv: to_xjv,
  of_xjv: of_xjv,
  json_of_xjv: json_of_xjv,
  json_of_jv: json_of_jv,
  xjv_of_json_exn: xjv_of_json_exn,
  xjv_of_json: xjv_of_json,
  jv_of_json_exn: jv_of_json_exn,
  jv_of_json: jv_of_json,
  TestSamples: TestSamples
};

function raw_backtrace_to_string(bt) {
  return $$String.concat("\n", bt);
}

function get_raw_backtrace(param) {
  var stacktrace = ((()=>{try { throw new Error();}catch(e){return e.stack}})());
  return $$String.split_on_char(/* '\n' */10, stacktrace);
}

var Printexc$1 = {
  to_string: Printexc.to_string,
  print: Printexc.print,
  $$catch: Printexc.$$catch,
  register_printer: Printexc.register_printer,
  raw_backtrace_to_string: raw_backtrace_to_string,
  get_raw_backtrace: get_raw_backtrace
};

var bytes0 = Bytes.init(12, Pervasives.char_of_int);

function bytes_of_uint8array(arr) {
  var len = arr.byteLength;
  return Bytes.init(len, (function (i) {
                return Pervasives.char_of_int(arr[i]);
              }));
}

function uint8array_of_bytes(bytes) {
  var len = bytes.length;
  var buf = new ArrayBuffer(len);
  var arr = new Uint8Array(buf);
  for(var i = 0; i < len; ++i){
    arr[i] = Caml_bytes.get(bytes, i);
  }
  return arr;
}

var JsInterop = {
  bytes0: bytes0,
  bytes_of_uint8array: bytes_of_uint8array,
  uint8array_of_bytes: uint8array_of_bytes
};

var Kxclib_comp_re = {
  BaseCompInternals: BaseCompInternals,
  Seq: Seq,
  $$Option: $$Option,
  $$Array: $$Array$1,
  Result: Result,
  List: List,
  Hashtbl: Hashtbl$1,
  Bytes: Bytes$1,
  $$String: $$String$1,
  Int: Int,
  Float: Float,
  $$Buffer: $$Buffer,
  Json_ext: Json_ext,
  Printexc: Printexc$1,
  JsInterop: JsInterop
};

var Kxclib_comp = {
  BaseCompInternals: BaseCompInternals,
  Seq: Seq,
  $$Option: $$Option,
  $$Array: $$Array$1,
  Result: Result,
  List: List,
  Hashtbl: Hashtbl$1,
  Bytes: Bytes$1,
  $$String: $$String$1,
  Int: Int,
  Float: Float,
  $$Buffer: $$Buffer,
  Json_ext: Json_ext,
  Printexc: Printexc$1,
  JsInterop: JsInterop
};

function refset(r, x) {
  r.contents = x;
  
}

function refupdate(r, f) {
  r.contents = Curry._1(f, r.contents);
  
}

function refappend(r, x) {
  r.contents = {
    hd: x,
    tl: r.contents
  };
  
}

function refupdate$p(f, r) {
  r.contents = Curry._1(f, r.contents);
  
}

function refappend$p(x, r) {
  r.contents = {
    hd: x,
    tl: r.contents
  };
  
}

function refpop(r) {
  var match = r.contents;
  if (match) {
    r.contents = match.tl;
    return match.hd;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function incr(param) {
  return refupdate$p((function (prim) {
                return prim + 1 | 0;
              }), param);
}

function decr(param) {
  return refupdate$p((function (prim) {
                return prim - 1 | 0;
              }), param);
}

function refupdate$p_and_get(f, r) {
  r.contents = Curry._1(f, r.contents);
  return r.contents;
}

function get_and_refupdate$p(f, r) {
  var x = r.contents;
  r.contents = Curry._1(f, r.contents);
  return x;
}

function incr_and_get(param) {
  return refupdate$p_and_get((function (prim) {
                return prim + 1 | 0;
              }), param);
}

function decr_and_get(param) {
  return refupdate$p_and_get((function (prim) {
                return prim - 1 | 0;
              }), param);
}

function get_and_incr(param) {
  return get_and_refupdate$p((function (prim) {
                return prim + 1 | 0;
              }), param);
}

function get_and_decr(param) {
  return get_and_refupdate$p((function (prim) {
                return prim - 1 | 0;
              }), param);
}

function constant(c, param) {
  return c;
}

function identity(x) {
  return x;
}

function failwith$p(fmt) {
  return Format.kasprintf(Pervasives.failwith, fmt);
}

function invalid_arg$p(fmt) {
  return Format.kasprintf(Pervasives.invalid_arg, fmt);
}

function iotaf(n, func) {
  var loop = function (_acc, _m) {
    while(true) {
      var m = _m;
      var acc = _acc;
      if (m === n) {
        return acc;
      }
      _m = m + 1 | 0;
      _acc = {
        hd: Curry._1(func, m),
        tl: acc
      };
      continue ;
    };
  };
  return Belt_List.reverse(loop(/* [] */0, 0));
}

function iotaf$p(n, func) {
  var _m = 0;
  while(true) {
    var m = _m;
    if (m === n) {
      return ;
    }
    Curry._1(func, m);
    _m = m + 1 | 0;
    continue ;
  };
}

function iotafl(n, func, acc0) {
  var _acc = acc0;
  var _m = 0;
  while(true) {
    var m = _m;
    var acc = _acc;
    if (m === n) {
      return acc;
    }
    _m = m + 1 | 0;
    _acc = Curry._2(func, acc, m);
    continue ;
  };
}

function min_by(f, x, y) {
  if (Caml_obj.caml_greaterthan(Curry._1(f, y), Curry._1(f, x))) {
    return x;
  } else {
    return y;
  }
}

function max_by(f, x, y) {
  if (Caml_obj.caml_lessthan(Curry._1(f, y), Curry._1(f, x))) {
    return x;
  } else {
    return y;
  }
}

function negate(pred, x) {
  return !Curry._1(pred, x);
}

function both(p, g, x) {
  if (Curry._1(p, x)) {
    return Curry._1(g, x);
  } else {
    return false;
  }
}

function either(p, g, x) {
  if (Curry._1(p, x)) {
    return true;
  } else {
    return Curry._1(g, x);
  }
}

function dig2nd(f, a, b) {
  return Curry._2(f, b, a);
}

function dig3rd(f, a, b, c) {
  return Curry._3(f, c, a, b);
}

function fix1st(x, f) {
  return Curry._1(f, x);
}

function fix2nd(y, f, x) {
  return Curry._2(f, x, y);
}

function fix3rd(z, f, x, y) {
  return Curry._3(f, x, y, z);
}

function fix1st$p(x, f, param) {
  return Curry._1(f, x);
}

function tap(f, x) {
  Curry._1(f, x);
  return x;
}

function reptill(judge, f, x) {
  var _y = Curry._1(f, x);
  while(true) {
    var y = _y;
    if (Curry._1(judge, y)) {
      return y;
    }
    _y = Curry._1(f, x);
    continue ;
  };
}

function ntimes(n, f, x) {
  var _acc = x;
  var _n = n;
  while(true) {
    var n$1 = _n;
    var acc = _acc;
    if (n$1 === 0) {
      return acc;
    }
    _n = n$1 - 1 | 0;
    _acc = Curry._1(f, acc);
    continue ;
  };
}

function dotill(judge, f, x) {
  var _y = Curry._1(f, x);
  while(true) {
    var y = _y;
    if (Curry._1(judge, y)) {
      return y;
    }
    _y = Curry._1(f, y);
    continue ;
  };
}

function fixpoint(maxn) {
  if (maxn !== undefined) {
    if (maxn !== 0) {
      return function (f, x) {
        var _n = maxn - 1 | 0;
        var _param = [
          x,
          Curry._1(f, x)
        ];
        while(true) {
          var param = _param;
          var n = _n;
          var x$p = param[1];
          if (n === 0) {
            return x$p;
          }
          var x$1 = param[0];
          if (Caml_obj.caml_equal(x$1, x$p)) {
            return x$1;
          }
          _param = [
            x$p,
            Curry._1(f, x$p)
          ];
          _n = n - 1 | 0;
          continue ;
        };
      };
    } else {
      return function (param, x) {
        return x;
      };
    }
  } else {
    return function (f, x) {
      var _param = [
        x,
        Curry._1(f, x)
      ];
      while(true) {
        var param = _param;
        var x$p = param[1];
        var x$1 = param[0];
        if (Caml_obj.caml_equal(x$1, x$p)) {
          return x$1;
        }
        _param = [
          x$p,
          Curry._1(f, x$p)
        ];
        continue ;
      };
    };
  }
}

function converge$p(judge, f) {
  return function (x) {
    var _n = 1;
    var _param = [
      x,
      Curry._1(f, x)
    ];
    while(true) {
      var param = _param;
      var n = _n;
      var x$p = param[1];
      if (Curry._3(judge, n, param[0], x$p)) {
        return {
                TAG: /* Ok */0,
                _0: x$p
              };
      }
      _param = [
        x$p,
        Curry._1(f, x$p)
      ];
      _n = n + 1 | 0;
      continue ;
    };
  };
}

function converge(judge, f, x) {
  return converge$p((function (param, x, x$p) {
                  return Curry._2(judge, x, x$p);
                }), f)(x);
}

function $percent(f, g, x) {
  return Curry._1(f, Curry._1(g, x));
}

function $percent$percent(f, g, x, y) {
  return Curry._2(f, x, Curry._1(g, y));
}

function $amp$great(g, f, x) {
  return Curry._1(f, Curry._1(g, x));
}

function $amp$amp$great(g, f, x, y) {
  return Curry._1(f, Curry._2(g, x, y));
}

function $pipe$neg$great(x, f) {
  Curry._1(f, x);
  return x;
}

function $slash$slash(fa, fb, param) {
  return [
          Curry._1(fa, param[0]),
          Curry._1(fb, param[1])
        ];
}

function $slash$great(param, f) {
  return [
          param[0],
          Curry._1(f, param[1])
        ];
}

function $slash$less(param, f) {
  return [
          Curry._1(f, param[0]),
          param[1]
        ];
}

function $question$great(f, param) {
  return [
          param[0],
          Curry._1(f, param[1])
        ];
}

function $question$less(f, param) {
  return [
          Curry._1(f, param[0]),
          param[1]
        ];
}

function $bang$bang(f, param) {
  return Curry._2(f, param[0], param[1]);
}

function $bang$question(f, a, b) {
  return Curry._1(f, [
              a,
              b
            ]);
}

var BasicInfix = {
  $percent: $percent,
  $percent$percent: $percent$percent,
  $amp$great: $amp$great,
  $amp$amp$great: $amp$amp$great,
  $pipe$neg$great: $pipe$neg$great,
  $slash$slash: $slash$slash,
  $slash$great: $slash$great,
  $slash$less: $slash$less,
  $question$great: $question$great,
  $question$less: $question$less,
  $bang$bang: $bang$bang,
  $bang$question: $bang$question
};

var CommonTypes = {};

var Functionals = {
  negate: negate,
  both: both,
  either: either,
  dig2nd: dig2nd,
  dig3rd: dig3rd,
  flip: dig2nd,
  fix1st: fix1st,
  fix2nd: fix2nd,
  fix3rd: fix3rd,
  fix1st$p: fix1st$p,
  tap: tap,
  reptill: reptill,
  ntimes: ntimes,
  dotill: dotill,
  fixpoint: fixpoint,
  converge$p: converge$p,
  converge: converge,
  BasicInfix: BasicInfix,
  CommonTypes: CommonTypes,
  Infix: undefined
};

function PipeOps(S) {
  var $pipe$amp$great = function (xs, f) {
    return Curry._2(S.map, f, xs);
  };
  var $pipe$plus$amp$great = function (xs, f) {
    return Curry._2(S.map, (function (x) {
                  return [
                          x,
                          Curry._1(f, x)
                        ];
                }), xs);
  };
  var $pipe$bang$great = function (xs, f) {
    return Curry._2(S.iter, f, xs);
  };
  var $pipe$neg$bang$great = function (xs, f) {
    Curry._2(S.iter, f, xs);
    return xs;
  };
  var $pipe$at$great = function (xs, param) {
    var f = param[1];
    return Curry._3(S.fold_left, (function (acc, x) {
                  return Curry._1(f, [
                              acc,
                              x
                            ]);
                }), param[0], xs);
  };
  var $pipe$question$great = function (xs, f) {
    return Curry._2(S.filter, f, xs);
  };
  var $pipe$amp$question$great = function (xs, f) {
    return Curry._2(S.filter_map, f, xs);
  };
  var $pipe$plus$amp$question$great = function (xs, f) {
    return Curry._2(S.filter_map, (function (x) {
                  var y = Curry._1(f, x);
                  if (y !== undefined) {
                    return [
                            x,
                            Caml_option.valFromOption(y)
                          ];
                  }
                  
                }), xs);
  };
  return {
          $pipe$amp$great: $pipe$amp$great,
          $pipe$plus$amp$great: $pipe$plus$amp$great,
          $pipe$bang$great: $pipe$bang$great,
          $pipe$neg$bang$great: $pipe$neg$bang$great,
          $pipe$at$great: $pipe$at$great,
          $pipe$question$great: $pipe$question$great,
          $pipe$amp$question$great: $pipe$amp$question$great,
          $pipe$plus$amp$question$great: $pipe$plus$amp$question$great
        };
}

function MonadOps(M) {
  var $$return = function (x) {
    return Curry._1(M.$$return, x);
  };
  var $great$great$eq = M.bind;
  var $great$great = function (ma, mb) {
    return Curry._2($great$great$eq, ma, (function (param) {
                  return mb;
                }));
  };
  var $great$pipe$eq = function (ma, f) {
    return Curry._2($great$great$eq, ma, (function (x) {
                  return Curry._1(M.$$return, Curry._1(f, x));
                }));
  };
  var sequence_list = function (ms) {
    return Curry._2($great$great$eq, Belt_List.reduce(ms, Curry._1(M.$$return, /* [] */0), (function (acc, m) {
                      return Curry._2($great$great$eq, acc, (function (acc) {
                                    return Curry._2($great$great$eq, m, (function (x) {
                                                  return Curry._1(M.$$return, {
                                                              hd: x,
                                                              tl: acc
                                                            });
                                                }));
                                  }));
                    })), (function (xs) {
                  return Curry._1(M.$$return, Belt_List.reverse(xs));
                }));
  };
  var $great$great$eq$star = function (ms, af) {
    return Curry._2($great$great$eq, sequence_list(ms), af);
  };
  return {
          $$return: $$return,
          $great$great$eq: $great$great$eq,
          $great$great: $great$great,
          $great$pipe$eq: $great$pipe$eq,
          sequence_list: sequence_list,
          $great$great$eq$star: $great$great$eq$star
        };
}

function foldr(f, z, l) {
  return fold_right$1(f, l, z);
}

function projected_compare(proj, a, b) {
  return Caml_obj.caml_compare(Curry._1(proj, a), Curry._1(proj, b));
}

function left(x) {
  return {
          TAG: /* Left */0,
          _0: x
        };
}

function right(x) {
  return {
          TAG: /* Right */1,
          _0: x
        };
}

var Either = {
  left: left,
  right: right
};

function concat(rs) {
  var _acc = /* [] */0;
  var _param = Belt_List.reverse(rs);
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return {
              TAG: /* Ok */0,
              _0: acc
            };
    }
    var x = param.hd;
    if (x.TAG !== /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: x._0
            };
    }
    _param = param.tl;
    _acc = {
      hd: x._0,
      tl: acc
    };
    continue ;
  };
}

var Result$1 = {
  ok: ok,
  error: error,
  value: value$1,
  get_ok: get_ok,
  get_error: get_error,
  bind: bind$1,
  join: join$1,
  map: map$3,
  map_error: map_error,
  fold: fold$1,
  iter: iter$3,
  iter_error: iter_error,
  is_ok: is_ok,
  is_error: is_error,
  equal: equal$1,
  compare: compare$1,
  to_option: to_option,
  to_list: to_list$2,
  to_seq: to_seq$2,
  concat: concat
};

function ResultOf(E) {
  return {
          bind: bind$1,
          $$return: ok
        };
}

function protect$p(handler, f, x) {
  try {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(f, x)
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            TAG: /* Error */1,
            _0: Curry._1(handler, exn)
          };
  }
}

function protect(f) {
  return function (param) {
    return protect$p(Printexc.to_string, f, param);
  };
}

var ResultWithErrmsg = {
  bind: bind$1,
  $$return: ok,
  protect$p: protect$p,
  protect: protect
};

function is_empty(param) {
  if (param[0] || param[1]) {
    return false;
  } else {
    return true;
  }
}

function push(x, param) {
  return [
          {
            hd: x,
            tl: param[0]
          },
          param[1]
        ];
}

function push_front(x, param) {
  return [
          param[0],
          {
            hd: x,
            tl: param[1]
          }
        ];
}

function pop(_param) {
  while(true) {
    var param = _param;
    var u = param[1];
    var r = param[0];
    if (u) {
      return [
              u.hd,
              [
                r,
                u.tl
              ]
            ];
    }
    if (!r) {
      return ;
    }
    _param = [
      /* [] */0,
      Belt_List.reverse(r)
    ];
    continue ;
  };
}

function peek(_q) {
  while(true) {
    var q = _q;
    var u = q[1];
    var r = q[0];
    if (u) {
      return [
              u.hd,
              q
            ];
    }
    if (!r) {
      return ;
    }
    _q = [
      /* [] */0,
      Belt_List.reverse(r)
    ];
    continue ;
  };
}

var Queue_empty = [
  /* [] */0,
  /* [] */0
];

var Queue = {
  empty: Queue_empty,
  is_empty: is_empty,
  push: push,
  push_front: push_front,
  pop: pop,
  peek: peek
};

function v($$default, x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return $$default;
  }
}

function v$p(gen_default, x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return Curry._1(gen_default, undefined);
  }
}

function otherwise(otherwise$1, x) {
  if (x !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(x));
  } else {
    return otherwise$1;
  }
}

function pp(vpp, ppf, x) {
  if (x !== undefined) {
    return Curry._2(Format.fprintf(ppf, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Some(",
                      _1: {
                        TAG: /* Alpha */15,
                        _0: {
                          TAG: /* Char_literal */12,
                          _0: /* ')' */41,
                          _1: /* End_of_format */0
                        }
                      }
                    },
                    _1: "Some(%a)"
                  }), vpp, Caml_option.valFromOption(x));
  } else {
    return Format.fprintf(ppf, /* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "None",
                  _1: /* End_of_format */0
                },
                _1: "None"
              });
  }
}

function filter$1(pred, x) {
  if (x === undefined) {
    return ;
  }
  var x$1 = Caml_option.valFromOption(x);
  if (Curry._1(pred, x$1)) {
    return Caml_option.some(x$1);
  }
  
}

function fmap(f, v) {
  if (v === undefined) {
    return ;
  }
  var v$1 = Curry._1(f, Caml_option.valFromOption(v));
  if (v$1 !== undefined) {
    return Caml_option.valFromOption(v$1);
  }
  
}

function of_bool(param) {
  if (param) {
    return Caml_option.some(undefined);
  }
  
}

function some_if(cond, x) {
  if (cond) {
    return Caml_option.some(x);
  }
  
}

var $$Option$1 = {
  or_exn: or_exn,
  or_not_found: or_not_found,
  none: undefined,
  some: some,
  value: value,
  get: get,
  bind: bind,
  join: join,
  map: map$1,
  fold: fold,
  iter: iter$1,
  is_none: is_none,
  is_some: is_some,
  equal: equal,
  compare: compare,
  to_result: to_result,
  to_list: to_list,
  to_seq: to_seq,
  $$return: some,
  v: v,
  v$p: v$p,
  otherwise: otherwise,
  pp: pp,
  filter: filter$1,
  fmap: fmap,
  of_bool: of_bool,
  some_if: some_if
};

function $great$question(o, f) {
  return map$1(f, o);
}

var $great$great$question = bind;

function $pipe$question(o, v$1) {
  return v(v$1, o);
}

function $pipe$pipe$question(o1, o2) {
  return otherwise(o2, o1);
}

function $amp$great$question(af, f) {
  return function (param) {
    return map$1(f, Curry._1(af, param));
  };
}

function $pipe$amp$great(xs, f) {
  return function (param) {
    return map(f, xs, param);
  };
}

function $pipe$plus$amp$great(xs, f) {
  return function (param) {
    return map((function (x) {
                  return [
                          x,
                          Curry._1(f, x)
                        ];
                }), xs, param);
  };
}

function $pipe$bang$great(xs, f) {
  return iter(f, xs);
}

function $pipe$neg$bang$great(xs, f) {
  iter(f, xs);
  return xs;
}

function $pipe$at$great(xs, param) {
  var f = param[1];
  return fold_left((function (acc, x) {
                return Curry._1(f, [
                            acc,
                            x
                          ]);
              }), param[0], xs);
}

function $pipe$question$great(xs, f) {
  return function (param) {
    return filter(f, xs, param);
  };
}

function $pipe$amp$question$great(xs, f) {
  return function (param) {
    return filter_map(f, xs, param);
  };
}

function $pipe$plus$amp$question$great(xs, f) {
  return function (param) {
    return filter_map((function (x) {
                  var y = Curry._1(f, x);
                  if (y !== undefined) {
                    return [
                            x,
                            Caml_option.valFromOption(y)
                          ];
                  }
                  
                }), xs, param);
  };
}

function from(f) {
  var next = function (param) {
    var x = Curry._1(f, undefined);
    if (x !== undefined) {
      return /* Cons */{
              _0: Caml_option.valFromOption(x),
              _1: next
            };
    } else {
      return /* Nil */0;
    }
  };
  return next;
}

function iota(until_exclusive) {
  var counter = {
    contents: 0
  };
  return from(function (param) {
              var x = counter.contents;
              if (x === until_exclusive) {
                return ;
              } else {
                refupdate$p((function (prim) {
                        return prim + 1 | 0;
                      }), counter);
                return x;
              }
            });
}

function length$3(s) {
  return fold_left((function (c, param) {
                return c + 1 | 0;
              }), 0, s);
}

function range(ieOpt, start, end_) {
  var ie = ieOpt !== undefined ? ieOpt : false;
  var end_exclusive = ie ? end_ + 1 | 0 : end_;
  var f = function (param) {
    return start + param | 0;
  };
  var xs = iota(end_exclusive - start | 0);
  return function (param) {
    return map(f, xs, param);
  };
}

function $$enum(start) {
  var counter = {
    contents: start
  };
  return from(function (param) {
              return Caml_option.some(get_and_refupdate$p((function (prim) {
                                return prim + 1 | 0;
                              }), counter));
            });
}

function limited(quota, orig, param) {
  if (quota <= 0) {
    return /* Nil */0;
  }
  var match = Curry._1(orig, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var next = match._1;
  var partial_arg = quota - 1 | 0;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return limited(partial_arg, next, param);
            })
        };
}

function iteri$2(f, s) {
  var _i = 0;
  var _param = Curry._1(s, undefined);
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return ;
    }
    Curry._2(f, i, param._0);
    _param = Curry._1(param._1, undefined);
    _i = i + 1 | 0;
    continue ;
  };
}

function hd$1(s) {
  var match = Curry._1(s, undefined);
  if (match) {
    return match._0;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function tl$1(s) {
  var match = Curry._1(s, undefined);
  if (match) {
    return match._1;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function take(n, s) {
  if (n < 0) {
    return Pervasives.failwith("panic");
  }
  var h = function (n, t, param) {
    var match = Curry._1(t, undefined);
    if (n === 0) {
      return /* Nil */0;
    }
    if (!match) {
      return Pervasives.failwith("panic");
    }
    var u = match._1;
    var partial_arg = n - 1 | 0;
    return /* Cons */{
            _0: match._0,
            _1: (function (param) {
                return h(partial_arg, u, param);
              })
          };
  };
  return function (param) {
    return h(n, s, param);
  };
}

function drop(n, s) {
  return ntimes(n, tl$1, s);
}

function make$1(n, x) {
  if (n < 0) {
    return Pervasives.failwith("panic");
  }
  var h = function (i, param) {
    if (i === 0) {
      return /* Nil */0;
    }
    var partial_arg = i - 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return h(partial_arg, param);
              })
          };
  };
  return function (param) {
    return h(n, param);
  };
}

var Seq$1 = {
  empty: empty,
  $$return: $$return,
  cons: cons,
  append: append,
  map: map,
  filter_map: filter_map,
  filter: filter,
  flat_map: flat_map,
  flat_map_app: flat_map_app,
  fold_left: fold_left,
  iter: iter,
  unfold: unfold,
  $pipe$amp$great: $pipe$amp$great,
  $pipe$plus$amp$great: $pipe$plus$amp$great,
  $pipe$bang$great: $pipe$bang$great,
  $pipe$neg$bang$great: $pipe$neg$bang$great,
  $pipe$at$great: $pipe$at$great,
  $pipe$question$great: $pipe$question$great,
  $pipe$amp$question$great: $pipe$amp$question$great,
  $pipe$plus$amp$question$great: $pipe$plus$amp$question$great,
  from: from,
  iota: iota,
  length: length$3,
  range: range,
  $$enum: $$enum,
  limited: limited,
  iteri: iteri$2,
  hd: hd$1,
  tl: tl$1,
  take: take,
  drop: drop,
  make: make$1
};

function filter$2(f, arr) {
  var partial_arg = to_seq$1(arr);
  return of_seq(function (param) {
              return filter(f, partial_arg, param);
            });
}

function filter_map$2(f, arr) {
  var partial_arg = to_seq$1(arr);
  return of_seq(function (param) {
              return filter_map(f, partial_arg, param);
            });
}

function $pipe$amp$great$1(xs, f) {
  return map$2(f, xs);
}

function $pipe$plus$amp$great$1(xs, f) {
  return map$2((function (x) {
                return [
                        x,
                        Curry._1(f, x)
                      ];
              }), xs);
}

function $pipe$bang$great$1(xs, f) {
  return iter$2(f, xs);
}

function $pipe$neg$bang$great$1(xs, f) {
  iter$2(f, xs);
  return xs;
}

function $pipe$at$great$1(xs, param) {
  var f = param[1];
  return fold_left$1((function (acc, x) {
                return Curry._1(f, [
                            acc,
                            x
                          ]);
              }), param[0], xs);
}

function $pipe$question$great$1(xs, f) {
  return filter$2(f, xs);
}

function $pipe$amp$question$great$1(xs, f) {
  return filter_map$2(f, xs);
}

function $pipe$plus$amp$question$great$1(xs, f) {
  return filter_map$2((function (x) {
                var y = Curry._1(f, x);
                if (y !== undefined) {
                  return [
                          x,
                          Caml_option.valFromOption(y)
                        ];
                }
                
              }), xs);
}

function of_list_of_length(len, list) {
  var cell = {
    contents: list
  };
  return init(len, (function (param) {
                var match = cell.contents;
                if (match) {
                  cell.contents = match.tl;
                  return match.hd;
                }
                throw {
                      RE_EXN_ID: "Not_found",
                      Error: new Error()
                    };
              }));
}

function mean(fOpt, arr) {
  var f = fOpt !== undefined ? fOpt : identity;
  var len = arr.length;
  if (len === 0) {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  var labor = function (left, right) {
    var rlen = right - left | 0;
    if (rlen === 0) {
      return [
              Curry._1(f, Belt_Array.getExn(arr, left)),
              1
            ];
    }
    if (rlen === 1) {
      return [
              (Curry._1(f, Belt_Array.getExn(arr, left)) + Curry._1(f, Belt_Array.getExn(arr, right))) / 2,
              2
            ];
    }
    if (rlen < 0) {
      return [
              0,
              0
            ];
    }
    var mid = left + (rlen / 2 | 0) | 0;
    var match = labor(left, mid);
    var lw = match[1];
    var match$1 = labor(mid + 1 | 0, right);
    var rw = match$1[1];
    return [
            (match[0] * lw + match$1[0] * rw) / (lw + rw | 0),
            lw + rw | 0
          ];
  };
  return labor(0, len - 1 | 0)[0];
}

function min(cmp, arr) {
  var match = arr.length;
  if (match !== 0) {
    var cand = {
      contents: Belt_Array.getExn(arr, 0)
    };
    iter$2((function (x) {
            if (Curry._2(cmp, x, cand.contents) < 0) {
              cand.contents = x;
              return ;
            }
            
          }), arr);
    return cand.contents;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function max(cmp, arr) {
  var match = arr.length;
  if (match !== 0) {
    var cand = {
      contents: Belt_Array.getExn(arr, 0)
    };
    iter$2((function (x) {
            if (Curry._2(cmp, x, cand.contents) > 0) {
              cand.contents = x;
              return ;
            }
            
          }), arr);
    return cand.contents;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function first(arr) {
  var match = arr.length;
  if (match !== 0) {
    return Belt_Array.getExn(arr, 0);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function last(arr) {
  var n = arr.length;
  if (n !== 0) {
    return Belt_Array.getExn(arr, n - 1 | 0);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function sorted(cmp, arr) {
  sort(cmp, arr);
  return arr;
}

function update(f, arr, idx) {
  return Belt_Array.setExn(arr, idx, Curry._1(f, Belt_Array.getExn(arr, idx)));
}

function update_each(f, arr) {
  return iteri((function (i, x) {
                return Belt_Array.setExn(arr, i, Curry._2(f, i, x));
              }), arr);
}

function blastsati(pred, arr) {
  var pred$1 = function (i) {
    return Curry._1(pred, Belt_Array.getExn(arr, i));
  };
  var _l = 0;
  var _r = arr.length - 1 | 0;
  while(true) {
    var r = _r;
    var l = _l;
    if (l > r) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    if ((l + 1 | 0) === r) {
      if (Curry._1(pred$1, r)) {
        return r;
      } else {
        return l;
      }
    }
    if (l === r) {
      if (l === 0 && !Curry._1(pred$1, l)) {
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
      }
      return l;
    }
    var m = (l + r | 0) / 2 | 0;
    if (Curry._1(pred$1, m)) {
      _l = m;
      continue ;
    }
    _r = m - 1 | 0;
    continue ;
  };
}

function blastsat(pred, arr) {
  return Belt_Array.getExn(arr, blastsati(pred, arr));
}

function swap(arr, idx1, idx2) {
  var tmp = Belt_Array.getExn(arr, idx2);
  Belt_Array.setExn(arr, idx2, Belt_Array.getExn(arr, idx1));
  return Belt_Array.setExn(arr, idx1, tmp);
}

function shuffle(rngOpt, arr) {
  var rng = rngOpt !== undefined ? rngOpt : Random.$$int;
  var len = arr.length;
  for(var i = len - 1 | 0; i >= 1; --i){
    swap(arr, i, Curry._1(rng, i + 1 | 0));
  }
  
}

var to_function = Belt_Array.getExn;

var $$Array$2 = {
  B: B,
  Imported: Imported,
  length: length,
  get: get$1,
  set: set,
  make: make,
  create: create,
  Internals: Internals,
  init: init,
  copy: copy,
  append: append$1,
  sub: sub,
  fill: fill,
  blit: blit,
  iter: iter$2,
  iter2: iter2,
  map: map$2,
  map2: map2,
  iteri: iteri,
  mapi: mapi,
  to_list: to_list$1,
  list_length: list_length,
  of_list: of_list,
  fold_left: fold_left$1,
  fold_right: fold_right,
  exists: exists,
  for_all: for_all,
  for_all2: for_all2,
  exists2: exists2,
  mem: mem,
  memq: memq,
  Bottom: Bottom,
  sort: sort,
  cutoff: 5,
  stable_sort: stable_sort,
  fast_sort: stable_sort,
  to_seq: to_seq$1,
  to_seqi: to_seqi,
  of_rev_list: of_rev_list,
  of_seq: of_seq,
  filter: filter$2,
  filter_map: filter_map$2,
  $pipe$amp$great: $pipe$amp$great$1,
  $pipe$plus$amp$great: $pipe$plus$amp$great$1,
  $pipe$bang$great: $pipe$bang$great$1,
  $pipe$neg$bang$great: $pipe$neg$bang$great$1,
  $pipe$at$great: $pipe$at$great$1,
  $pipe$question$great: $pipe$question$great$1,
  $pipe$amp$question$great: $pipe$amp$question$great$1,
  $pipe$plus$amp$question$great: $pipe$plus$amp$question$great$1,
  of_list_of_length: of_list_of_length,
  mean: mean,
  min: min,
  max: max,
  first: first,
  last: last,
  sorted: sorted,
  update: update,
  update_each: update_each,
  blastsati: blastsati,
  blastsat: blastsat,
  swap: swap,
  shuffle: shuffle,
  to_function: to_function
};

function to_list_rev(stream) {
  var result = {
    contents: /* [] */0
  };
  Stream.iter((function (value) {
          result.contents = {
            hd: value,
            tl: result.contents
          };
          
        }), stream);
  return result.contents;
}

function to_list$3(stream) {
  return Belt_List.reverse(to_list_rev(stream));
}

function hd$2(stream) {
  try {
    return Stream.next(stream);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stream.Failure) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    throw exn;
  }
}

function drop1(stream) {
  try {
    Stream.next(stream);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stream.Failure) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    throw exn;
  }
  return stream;
}

function take$1(n, stream) {
  var m_lst;
  try {
    m_lst = Stream.npeek(n, stream);
  }
  catch (raw_msg){
    var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.RE_EXN_ID === Stream.Failure) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    if (msg.RE_EXN_ID === Stream.$$Error) {
      m_lst = Pervasives.failwith(msg._1);
    } else {
      throw msg;
    }
  }
  var m = Belt_List.length(m_lst);
  if (m === n) {
    return m_lst;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function drop$1(n, s) {
  return ntimes(n, drop1, s);
}

var Stream$1 = {
  Failure: Stream.Failure,
  $$Error: Stream.$$Error,
  from: Stream.from,
  of_list: Stream.of_list,
  of_string: Stream.of_string,
  of_bytes: Stream.of_bytes,
  of_channel: Stream.of_channel,
  iter: Stream.iter,
  next: Stream.next,
  empty: Stream.empty,
  peek: Stream.peek,
  junk: Stream.junk,
  count: Stream.count,
  npeek: Stream.npeek,
  iapp: Stream.iapp,
  icons: Stream.icons,
  ising: Stream.ising,
  lapp: Stream.lapp,
  lcons: Stream.lcons,
  lsing: Stream.lsing,
  sempty: undefined,
  slazy: Stream.slazy,
  dump: Stream.dump,
  to_list_rev: to_list_rev,
  to_list: to_list$3,
  hd: hd$2,
  drop1: drop1,
  take: take$1,
  drop: drop$1
};

function $pipe$amp$great$2(xs, f) {
  return map$4(f, xs);
}

function $pipe$plus$amp$great$2(xs, f) {
  return map$4((function (x) {
                return [
                        x,
                        Curry._1(f, x)
                      ];
              }), xs);
}

function $pipe$bang$great$2(xs, f) {
  return iter$4(f, xs);
}

function $pipe$neg$bang$great$2(xs, f) {
  iter$4(f, xs);
  return xs;
}

function $pipe$at$great$2(xs, param) {
  var f = param[1];
  return fold_left$2((function (acc, x) {
                return Curry._1(f, [
                            acc,
                            x
                          ]);
              }), param[0], xs);
}

function $pipe$question$great$2(xs, f) {
  return find_all(f, xs);
}

function $pipe$amp$question$great$2(xs, f) {
  return filter_map$1(f, xs);
}

function $pipe$plus$amp$question$great$2(xs, f) {
  return filter_map$1((function (x) {
                var y = Curry._1(f, x);
                if (y !== undefined) {
                  return [
                          x,
                          Caml_option.valFromOption(y)
                        ];
                }
                
              }), xs);
}

function iota$1(k) {
  if (k !== 0) {
    return {
            hd: 0,
            tl: Belt_List.makeBy(k - 1 | 0, (function (prim) {
                    return prim + 1 | 0;
                  }))
          };
  } else {
    return /* [] */0;
  }
}

function helper(start, end_) {
  var f = function (param) {
    return start + param | 0;
  };
  var xs = iota$1(end_ - start | 0);
  return map$4(f, xs);
}

function range$1(ieOpt) {
  var ie = ieOpt !== undefined ? ieOpt : false;
  if (ie) {
    return function (start, end_) {
      return helper(start, end_ + 1 | 0);
    };
  } else {
    return helper;
  }
}

function dedup$p(by, l) {
  var set = Hashtbl.create(undefined, Belt_List.length(l));
  return find_all((function (x) {
                if (Hashtbl.mem(set, Curry._1(by, x))) {
                  return false;
                } else {
                  Hashtbl.add(set, Curry._1(by, x), true);
                  return true;
                }
              }), l);
}

function dedup(l) {
  return dedup$p(identity, l);
}

function update_assoc(k, func, l) {
  var match = Belt_List.reduce(l, [
        /* [] */0,
        false
      ], (function (param, ent) {
          var key = ent[0];
          var updated = param[1];
          var acc = param[0];
          var match = Caml_obj.caml_equal(k, key);
          if (updated) {
            return [
                    {
                      hd: ent,
                      tl: acc
                    },
                    updated
                  ];
          }
          if (!match) {
            return [
                    {
                      hd: ent,
                      tl: acc
                    },
                    updated
                  ];
          }
          var v$p = Curry._1(func, Caml_option.some(ent[1]));
          if (v$p !== undefined) {
            return [
                    {
                      hd: [
                        key,
                        Caml_option.valFromOption(v$p)
                      ],
                      tl: acc
                    },
                    true
                  ];
          } else {
            return [
                    acc,
                    true
                  ];
          }
        }));
  if (match[1]) {
    return Belt_List.reverse(match[0]);
  }
  var v = Curry._1(func, undefined);
  if (v !== undefined) {
    return {
            hd: [
              k,
              Caml_option.valFromOption(v)
            ],
            tl: l
          };
  } else {
    return l;
  }
}

function update_assq(k, func, l) {
  var match = Belt_List.reduce(l, [
        /* [] */0,
        false
      ], (function (param, ent) {
          var key = ent[0];
          var updated = param[1];
          var acc = param[0];
          var match = k === key;
          if (updated) {
            return [
                    {
                      hd: ent,
                      tl: acc
                    },
                    updated
                  ];
          }
          if (!match) {
            return [
                    {
                      hd: ent,
                      tl: acc
                    },
                    updated
                  ];
          }
          var v$p = Curry._1(func, Caml_option.some(ent[1]));
          if (v$p !== undefined) {
            return [
                    {
                      hd: [
                        key,
                        Caml_option.valFromOption(v$p)
                      ],
                      tl: acc
                    },
                    true
                  ];
          } else {
            return [
                    acc,
                    true
                  ];
          }
        }));
  if (match[1]) {
    return Belt_List.reverse(match[0]);
  }
  var v = Curry._1(func, undefined);
  if (v !== undefined) {
    return {
            hd: [
              k,
              Caml_option.valFromOption(v)
            ],
            tl: l
          };
  } else {
    return l;
  }
}

function deassoc_opt(k, es) {
  var _param = [
    undefined,
    /* [] */0
  ];
  var _param$1 = es;
  while(true) {
    var param = _param;
    var param$1 = _param$1;
    var es$1 = param[1];
    var ret = param[0];
    if (!param$1) {
      return [
              ret,
              es$1
            ];
    }
    var rest = param$1.tl;
    var e = param$1.hd;
    if (Caml_obj.caml_equal(e[0], k)) {
      _param$1 = rest;
      _param = [
        Caml_option.some(e[1]),
        es$1
      ];
      continue ;
    }
    _param$1 = rest;
    _param = [
      ret,
      {
        hd: e,
        tl: es$1
      }
    ];
    continue ;
  };
}

function deassq_opt(k, es) {
  var _param = [
    undefined,
    /* [] */0
  ];
  var _param$1 = es;
  while(true) {
    var param = _param;
    var param$1 = _param$1;
    var es$1 = param[1];
    var ret = param[0];
    if (!param$1) {
      return [
              ret,
              es$1
            ];
    }
    var rest = param$1.tl;
    var e = param$1.hd;
    if (e[0] === k) {
      _param$1 = rest;
      _param = [
        Caml_option.some(e[1]),
        es$1
      ];
      continue ;
    }
    _param$1 = rest;
    _param = [
      ret,
      {
        hd: e,
        tl: es$1
      }
    ];
    continue ;
  };
}

function deassoc_opt$p(k, es) {
  var match = deassoc_opt(k, es);
  var v = match[0];
  if (v !== undefined) {
    return [
            Caml_option.valFromOption(v),
            match[1]
          ];
  }
  
}

function deassq_opt$p(k, es) {
  var match = deassq_opt(k, es);
  var v = match[0];
  if (v !== undefined) {
    return [
            Caml_option.valFromOption(v),
            match[1]
          ];
  }
  
}

function deassoc(k, es) {
  var match = deassoc_opt(k, es);
  return [
          v$p((function (param) {
                  throw {
                        RE_EXN_ID: "Not_found",
                        Error: new Error()
                      };
                }), match[0]),
          match[1]
        ];
}

function deassq(k, es) {
  var match = deassq_opt(k, es);
  return [
          v$p((function (param) {
                  throw {
                        RE_EXN_ID: "Not_found",
                        Error: new Error()
                      };
                }), match[0]),
          match[1]
        ];
}

function group_by(kf, l) {
  return Belt_List.reduce(l, /* [] */0, (function (acc, x) {
                var k = Curry._1(kf, x);
                return update_assoc(k, (function (xs) {
                              if (xs !== undefined) {
                                return {
                                        hd: x,
                                        tl: xs
                                      };
                              } else {
                                return {
                                        hd: x,
                                        tl: /* [] */0
                                      };
                              }
                            }), acc);
              }));
}

function unzip(l) {
  return Belt_List.reduce(Belt_List.reverse(l), [
              /* [] */0,
              /* [] */0
            ], (function (param, param$1) {
                return [
                        {
                          hd: param$1[0],
                          tl: param[0]
                        },
                        {
                          hd: param$1[1],
                          tl: param[1]
                        }
                      ];
              }));
}

function unzip3(l) {
  return Belt_List.reduce(Belt_List.reverse(l), [
              /* [] */0,
              /* [] */0,
              /* [] */0
            ], (function (param, param$1) {
                return [
                        {
                          hd: param$1[0],
                          tl: param[0]
                        },
                        {
                          hd: param$1[1],
                          tl: param[1]
                        },
                        {
                          hd: param$1[2],
                          tl: param[2]
                        }
                      ];
              }));
}

function reduce(f, param) {
  if (param) {
    return Belt_List.reduce(param.tl, param.hd, f);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function min$1(cmp, param) {
  if (param) {
    var f = function (acc, x) {
      if (Curry._2(cmp, acc, x) > 0) {
        return x;
      } else {
        return acc;
      }
    };
    return Belt_List.reduce(param.tl, param.hd, f);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function max$1(cmp, param) {
  if (param) {
    var f = function (acc, x) {
      if (Curry._2(cmp, acc, x) < 0) {
        return x;
      } else {
        return acc;
      }
    };
    return Belt_List.reduce(param.tl, param.hd, f);
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function hd$3(param) {
  if (param) {
    return param.hd;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function tl$2(param) {
  if (param) {
    return param.tl;
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function take$2(n, l) {
  var _acc = /* [] */0;
  var _param = [
    n,
    l
  ];
  while(true) {
    var param = _param;
    var acc = _acc;
    var n$1 = param[0];
    if (n$1 === 0) {
      return Belt_List.reverse(acc);
    }
    var match = param[1];
    if (match) {
      _param = [
        n$1 - 1 | 0,
        match.tl
      ];
      _acc = {
        hd: match.hd,
        tl: acc
      };
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function drop$2(n, l) {
  return ntimes(n, tl$2, l);
}

function make$2(copies, x) {
  return Belt_List.makeBy(copies, (function (param) {
                return x;
              }));
}

function count(pred, list) {
  return Belt_List.reduce(list, 0, (function (count, x) {
                if (Curry._1(pred, x)) {
                  return count + 1 | 0;
                } else {
                  return count;
                }
              }));
}

function last$1(list) {
  return Belt_List.reduce(list, hd(list), (function (param, x) {
                return x;
              }));
}

function and_last(xs) {
  var match = Belt_List.reverse(xs);
  if (match) {
    return [
            Belt_List.reverse(match.tl),
            match.hd
          ];
  }
  throw {
        RE_EXN_ID: "Not_found",
        Error: new Error()
      };
}

function fmap$1(f, l) {
  var loop = function (_acc, _param) {
    while(true) {
      var param = _param;
      var acc = _acc;
      if (!param) {
        return acc;
      }
      _param = param.tl;
      _acc = {
        hd: Belt_List.reverse(Curry._1(f, param.hd)),
        tl: acc
      };
      continue ;
    };
  };
  var _acc = /* [] */0;
  var _param = loop(/* [] */0, l);
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return acc;
    }
    var match = param.hd;
    if (match) {
      _param = {
        hd: match.tl,
        tl: param.tl
      };
      _acc = {
        hd: match.hd,
        tl: acc
      };
      continue ;
    }
    _param = param.tl;
    continue ;
  };
}

function interpolate(y, xs) {
  var loop = function (_acc, _param) {
    while(true) {
      var param = _param;
      var acc = _acc;
      if (!param) {
        return acc;
      }
      var xs = param.tl;
      var x = param.hd;
      if (!xs) {
        return {
                hd: x,
                tl: acc
              };
      }
      _param = xs;
      _acc = {
        hd: y,
        tl: {
          hd: x,
          tl: acc
        }
      };
      continue ;
    };
  };
  return Belt_List.reverse(loop(/* [] */0, xs));
}

function filteri$1(p, l) {
  var _i = 0;
  var _acc = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var acc = _acc;
    var i = _i;
    if (!param) {
      return Belt_List.reverse(acc);
    }
    var x = param.hd;
    _param = param.tl;
    _acc = Curry._2(p, i, x) ? ({
          hd: x,
          tl: acc
        }) : acc;
    _i = i + 1 | 0;
    continue ;
  };
}

function empty$1(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function to_function$1(xs) {
  var partial_arg = of_list(xs);
  return function (param) {
    return Belt_Array.getExn(partial_arg, param);
  };
}

function to_hashtbl(xs) {
  return of_seq$2(to_seq$3(xs));
}

function pp$1(sep, parens, vpp, ppf, xs) {
  var match = parens !== undefined ? parens : [
      "[",
      "]"
    ];
  var sep$1 = sep !== undefined ? sep : ";";
  Curry._1(Format.fprintf(ppf, /* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: {
                TAG: /* Char_literal */12,
                _0: /* ' ' */32,
                _1: {
                  TAG: /* Formatting_gen */18,
                  _0: {
                    TAG: /* Open_box */1,
                    _0: /* Format */{
                      _0: /* End_of_format */0,
                      _1: ""
                    }
                  },
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "%s @["
          }), match[0]);
  var partial_arg = Curry._1(Format.fprintf(ppf, /* Format */{
            _0: {
              TAG: /* Alpha */15,
              _0: {
                TAG: /* String */2,
                _0: /* No_padding */0,
                _1: {
                  TAG: /* Formatting_lit */17,
                  _0: {
                    TAG: /* Break */0,
                    _0: "@;",
                    _1: 1,
                    _2: 0
                  },
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "%a%s@;"
          }), vpp);
  Belt_List.forEach(xs, (function (param) {
          return Curry._2(partial_arg, param, sep$1);
        }));
  return Curry._1(Format.fprintf(ppf, /* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* Formatting_lit */17,
                      _0: /* Close_box */0,
                      _1: /* End_of_format */0
                    }
                  },
                  _1: "%s@]"
                }), match[1]);
}

function bind$2(ma, af) {
  return fmap$1(af, ma);
}

function $$return$1(x) {
  return {
          hd: x,
          tl: /* [] */0
        };
}

var List$1 = {
  $pipe$amp$great: $pipe$amp$great$2,
  $pipe$plus$amp$great: $pipe$plus$amp$great$2,
  $pipe$bang$great: $pipe$bang$great$2,
  $pipe$neg$bang$great: $pipe$neg$bang$great$2,
  $pipe$at$great: $pipe$at$great$2,
  $pipe$question$great: $pipe$question$great$2,
  $pipe$amp$question$great: $pipe$amp$question$great$2,
  $pipe$plus$amp$question$great: $pipe$plus$amp$question$great$2,
  B: B$1,
  length: length$1,
  nth_opt: nth_opt,
  nth: nth,
  append: Pervasives.$at,
  rev_append: rev_append,
  rev: rev,
  init: init$1,
  flatten: flatten,
  concat: flatten,
  map: map$4,
  mapi: mapi$1,
  rev_map: rev_map,
  iter: iter$4,
  iteri: iteri$1,
  fold_left: fold_left$2,
  fold_right: fold_right$1,
  map2: map2$1,
  rev_map2: rev_map2,
  iter2: iter2$1,
  for_all: for_all$1,
  exists: exists$1,
  for_all2: for_all2$1,
  exists2: exists2$1,
  mem: mem$1,
  memq: memq$1,
  assoc_opt: assoc_opt,
  assq_opt: assq_opt,
  assoc: assoc,
  assq: assq,
  mem_assoc: mem_assoc,
  mem_assq: mem_assq,
  remove_assoc: remove_assoc,
  remove_assq: remove_assq,
  find_opt: find_opt,
  find: find,
  find_map: find_map,
  find_all: find_all,
  filter: find_all,
  filter_map: filter_map$1,
  concat_map: concat_map,
  fold_left_map: fold_left_map,
  partition: partition,
  split: split,
  combine: combine,
  merge: merge,
  stable_sort: stable_sort$1,
  sort: stable_sort$1,
  fast_sort: stable_sort$1,
  compare: compare$2,
  equal: equal$2,
  to_seq: to_seq$3,
  of_seq: of_seq$1,
  iota: iota$1,
  range: range$1,
  dedup$p: dedup$p,
  dedup: dedup,
  update_assoc: update_assoc,
  update_assq: update_assq,
  deassoc_opt: deassoc_opt,
  deassq_opt: deassq_opt,
  deassoc_opt$p: deassoc_opt$p,
  deassq_opt$p: deassq_opt$p,
  deassoc: deassoc,
  deassq: deassq,
  group_by: group_by,
  unzip: unzip,
  unzip3: unzip3,
  reduce: reduce,
  min: min$1,
  max: max$1,
  foldl: fold_left$2,
  foldr: foldr,
  hd: hd$3,
  tl: tl$2,
  take: take$2,
  drop: drop$2,
  make: make$2,
  count: count,
  last: last$1,
  and_last: and_last,
  fmap: fmap$1,
  interpolate: interpolate,
  filteri: filteri$1,
  empty: empty$1,
  to_function: to_function$1,
  to_hashtbl: to_hashtbl,
  pp: pp$1,
  bind: bind$2,
  $$return: $$return$1
};

var $pipe$amp$great$3 = Belt_List.map;

function $pipe$plus$amp$great$3(xs, f) {
  return Belt_List.map(xs, (function (x) {
                return [
                        x,
                        Curry._1(f, x)
                      ];
              }));
}

var $pipe$bang$great$3 = Belt_List.forEach;

function $pipe$neg$bang$great$3(xs, f) {
  Belt_List.forEach(xs, f);
  return xs;
}

function $pipe$at$great$3(xs, param) {
  var f = param[1];
  return Belt_List.reduce(xs, param[0], (function (acc, x) {
                return Curry._1(f, [
                            acc,
                            x
                          ]);
              }));
}

var $pipe$question$great$3 = Belt_List.keep;

var $pipe$amp$question$great$3 = Belt_List.keepMap;

function $pipe$plus$amp$question$great$3(xs, f) {
  return Belt_List.keepMap(xs, (function (x) {
                var y = Curry._1(f, x);
                if (y !== undefined) {
                  return [
                          x,
                          Caml_option.valFromOption(y)
                        ];
                }
                
              }));
}

function rev$1(orig) {
  var partial_arg = to_seq$4(orig);
  return of_seq$2(function (param) {
              return map((function (param) {
                            return [
                                    param[1],
                                    param[0]
                                  ];
                          }), partial_arg, param);
            });
}

function make$3(random, n, genfunc) {
  var table = Hashtbl.create(random, n);
  var partial_arg = iota(n);
  add_seq(table, (function (param) {
          return map(genfunc, partial_arg, param);
        }));
  return table;
}

var Hashtbl$2 = {
  create: Hashtbl.create,
  clear: Hashtbl.clear,
  reset: Hashtbl.reset,
  copy: Hashtbl.copy,
  add: Hashtbl.add,
  find: Hashtbl.find,
  find_opt: Hashtbl.find_opt,
  find_all: Hashtbl.find_all,
  mem: Hashtbl.mem,
  remove: Hashtbl.remove,
  replace: Hashtbl.replace,
  iter: Hashtbl.iter,
  filter_map_inplace: Hashtbl.filter_map_inplace,
  fold: Hashtbl.fold,
  length: Hashtbl.length,
  randomize: Hashtbl.randomize,
  is_randomized: Hashtbl.is_randomized,
  stats: Hashtbl.stats,
  Make: Hashtbl.Make,
  MakeSeeded: Hashtbl.MakeSeeded,
  hash: Hashtbl.hash,
  seeded_hash: Hashtbl.seeded_hash,
  hash_param: Hashtbl.hash_param,
  seeded_hash_param: Hashtbl.seeded_hash_param,
  add_seq: add_seq,
  replace_seq: replace_seq,
  of_seq: of_seq$2,
  to_seq: to_seq$4,
  to_seq_keys: to_seq_keys,
  to_seq_values: to_seq_values,
  rev: rev$1,
  to_function: Hashtbl.find,
  make: make$3
};

function empty$2(str) {
  return str.length === 0;
}

function empty_trimmed(str) {
  return $$String.trim(str).length === 0;
}

function chop_prefix(prefix) {
  var plen = prefix.length;
  return function (str) {
    var slen = str.length;
    if (slen < plen || $$String.sub(str, 0, plen) !== prefix) {
      return ;
    } else {
      return $$String.sub(str, plen, slen - plen | 0);
    }
  };
}

function starts_with(prefix, str) {
  return is_some(chop_prefix(prefix)(str));
}

function ends_with(postfix, str) {
  var plen = postfix.length;
  var slen = str.length;
  if (slen < plen) {
    return false;
  } else {
    return $$String.sub(str, slen - plen | 0, plen) === postfix;
  }
}

function chop_suffix(suffix) {
  var plen = suffix.length;
  return function (str) {
    var slen = str.length;
    if (slen < plen || $$String.sub(str, slen - plen | 0, plen) !== suffix) {
      return ;
    } else {
      return $$String.sub(str, 0, slen - plen | 0);
    }
  };
}

function to_list$4(str) {
  return of_seq$1(to_seq$5(Bytes.unsafe_of_string(str)));
}

function of_list$1(param) {
  var g = to_seq$3(param);
  return Bytes.unsafe_to_string(of_seq$3(g));
}

function of_array(param) {
  var g = to_seq$1(param);
  return Bytes.unsafe_to_string(of_seq$3(g));
}

var $$String$2 = {
  make: $$String.make,
  init: $$String.init,
  sub: $$String.sub,
  blit: $$String.blit,
  concat: $$String.concat,
  iter: $$String.iter,
  iteri: $$String.iteri,
  map: $$String.map,
  mapi: $$String.mapi,
  trim: $$String.trim,
  escaped: $$String.escaped,
  index: $$String.index,
  index_opt: $$String.index_opt,
  rindex: $$String.rindex,
  rindex_opt: $$String.rindex_opt,
  index_from: $$String.index_from,
  index_from_opt: $$String.index_from_opt,
  rindex_from: $$String.rindex_from,
  rindex_from_opt: $$String.rindex_from_opt,
  contains: $$String.contains,
  contains_from: $$String.contains_from,
  rcontains_from: $$String.rcontains_from,
  uppercase: $$String.uppercase,
  lowercase: $$String.lowercase,
  capitalize: $$String.capitalize,
  uncapitalize: $$String.uncapitalize,
  uppercase_ascii: $$String.uppercase_ascii,
  lowercase_ascii: $$String.lowercase_ascii,
  capitalize_ascii: $$String.capitalize_ascii,
  uncapitalize_ascii: $$String.uncapitalize_ascii,
  compare: $$String.compare,
  equal: $$String.equal,
  split_on_char: $$String.split_on_char,
  B: B$2,
  bos: Bytes.unsafe_of_string,
  bts: Bytes.unsafe_to_string,
  to_seq: to_seq$6,
  to_seqi: to_seqi$2,
  of_seq: of_seq$4,
  empty: empty$2,
  empty_trimmed: empty_trimmed,
  chop_prefix: chop_prefix,
  starts_with: starts_with,
  ends_with: ends_with,
  chop_suffix: chop_suffix,
  to_bytes: Bytes.of_string,
  to_list: to_list$4,
  of_list: of_list$1,
  of_array: of_array
};

function with_input_file(path, f) {
  var ch = Pervasives.open_in(path);
  var r;
  try {
    r = Curry._1(f, ch);
  }
  catch (e){
    Pervasives.close_in(ch);
    throw e;
  }
  Pervasives.close_in(ch);
  return r;
}

function with_output_file(path, f) {
  var ch = Pervasives.open_out(path);
  var r;
  try {
    r = Curry._1(f, ch);
  }
  catch (e){
    Pervasives.close_out(ch);
    throw e;
  }
  Pervasives.close_out(ch);
  return r;
}

function slurp_input(buf, ic) {
  var buf$1 = buf !== undefined ? buf : Bytes.make(4096, /* '\000' */0);
  var result = {
    contents: ""
  };
  var loop = function (len) {
    while(true) {
      var rlen = Pervasives.input(ic, buf$1, 0, len);
      if (rlen === 0) {
        return result;
      }
      result.contents = result.contents + Bytes.sub_string(buf$1, 0, rlen);
      continue ;
    };
  };
  return loop(buf$1.length).contents;
}

function slurp_stdin(buf, param) {
  return slurp_input(buf, Pervasives.stdin);
}

function slurp_file(path) {
  return with_input_file(path, (function (eta) {
                return slurp_input(undefined, eta);
              }));
}

function spit_file(path, str) {
  return with_output_file(path, (function (param) {
                return Pervasives.output_string(param, str);
              }));
}

var IoPervasives = {
  with_input_file: with_input_file,
  with_output_file: with_output_file,
  slurp_input: slurp_input,
  slurp_stdin: slurp_stdin,
  slurp_file: slurp_file,
  spit_file: spit_file
};

function timefunc$p(output, f) {
  var t = Caml_sys.caml_sys_time(undefined);
  var r = Curry._1(f, undefined);
  output.contents = Caml_sys.caml_sys_time(undefined) - t;
  return r;
}

function timefunc(f) {
  var time = {
    contents: 0
  };
  timefunc$p(time, f);
  return time.contents;
}

var Timing = {
  timefunc$p: timefunc$p,
  timefunc: timefunc
};

var partial_arg = of_list({
      hd: 0,
      tl: {
        hd: 31,
        tl: {
          hd: 28,
          tl: {
            hd: 31,
            tl: {
              hd: 30,
              tl: {
                hd: 31,
                tl: {
                  hd: 30,
                  tl: {
                    hd: 31,
                    tl: {
                      hd: 31,
                      tl: {
                        hd: 30,
                        tl: {
                          hd: 31,
                          tl: {
                            hd: 30,
                            tl: {
                              hd: 31,
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

function days_of_months_nonleap(param) {
  return Belt_Array.getExn(partial_arg, param);
}

var partial_arg$1 = of_list({
      hd: 0,
      tl: {
        hd: 31,
        tl: {
          hd: 29,
          tl: {
            hd: 31,
            tl: {
              hd: 30,
              tl: {
                hd: 31,
                tl: {
                  hd: 30,
                  tl: {
                    hd: 31,
                    tl: {
                      hd: 31,
                      tl: {
                        hd: 30,
                        tl: {
                          hd: 31,
                          tl: {
                            hd: 30,
                            tl: {
                              hd: 31,
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

function days_of_months_leap(param) {
  return Belt_Array.getExn(partial_arg$1, param);
}

var xs = iota$1(13);

var xs$1 = map$4((function (x) {
        var xs = iota$1(x);
        var param = map$4(days_of_months_nonleap, xs);
        return Belt_List.reduce(param, 0, (function (prim0, prim1) {
                      return prim0 + prim1 | 0;
                    }));
      }), xs);

var partial_arg$2 = of_list(xs$1);

function days_of_months_subsum_nonleap(param) {
  return Belt_Array.getExn(partial_arg$2, param);
}

var xs$2 = iota$1(13);

var xs$3 = map$4((function (x) {
        var xs = iota$1(x);
        var param = map$4(days_of_months_leap, xs);
        return Belt_List.reduce(param, 0, (function (prim0, prim1) {
                      return prim0 + prim1 | 0;
                    }));
      }), xs$2);

var partial_arg$3 = of_list(xs$3);

function days_of_months_subsum_leap(param) {
  return Belt_Array.getExn(partial_arg$3, param);
}

function daycount_of_month(leap) {
  var table = leap ? days_of_months_leap : days_of_months_nonleap;
  return Curry.__1(table);
}

function leap_year(yy) {
  var div = function (x) {
    return Caml_int32.mod_(yy, x) === 0;
  };
  if (!div(4) || !(!div(100) || div(400))) {
    return false;
  } else {
    return true;
  }
}

function day_of_year(yy) {
  var table = leap_year(yy) ? days_of_months_subsum_leap : days_of_months_subsum_nonleap;
  return function (mm, dd) {
    return Curry._1(table, mm) + dd | 0;
  };
}

var span = (max_int - 1 | 0) / 31622400 | 0;

var max_year = (span - 1 | 0) + 1970 | 0;

var Conf = {
  epoch_year: 1970,
  subsecond_resolution: 1,
  min_year: 1970,
  max_year: max_year
};

function yearcount_leaping(ymin, ymax) {
  var roundup = function (div, x) {
    if (Caml_int32.mod_(x, div) === 0) {
      return x;
    } else {
      return Math.imul(div, Caml_int32.div(x, div) + 1 | 0);
    }
  };
  var ncat = function (div) {
    var span = ymax - roundup(div, ymin) | 0;
    if (span < 0) {
      return 0;
    } else {
      return Caml_int32.div(span, div) + 1 | 0;
    }
  };
  var ncat4 = ncat(4);
  var ncat100 = ncat(100);
  var ncat400 = ncat(400);
  return (ncat4 - ncat100 | 0) + ncat400 | 0;
}

function normalize(subsec, tzoffset, param, param$1) {
  var sec = param$1[2];
  var min = param$1[1];
  var hour = param$1[0];
  var dd = param[2];
  var mm = param[1];
  var yy = param[0];
  var subsec$1 = value(subsec, 0);
  if (yy < 1970 || yy > max_year) {
    Pervasives.invalid_arg(Curry.app(Format.asprintf(/* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ".normalize - timestamp cannot be handled: ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* Char_literal */12,
                          _0: /* '-' */45,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* Char_literal */12,
                              _0: /* '-' */45,
                              _1: {
                                TAG: /* Int */4,
                                _0: /* Int_d */0,
                                _1: /* No_padding */0,
                                _2: /* No_precision */0,
                                _3: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ' ' */32,
                                  _1: {
                                    TAG: /* Int */4,
                                    _0: /* Int_d */0,
                                    _1: {
                                      TAG: /* Lit_padding */0,
                                      _0: /* Zeros */2,
                                      _1: 2
                                    },
                                    _2: /* No_precision */0,
                                    _3: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ':' */58,
                                      _1: {
                                        TAG: /* Int */4,
                                        _0: /* Int_d */0,
                                        _1: {
                                          TAG: /* Lit_padding */0,
                                          _0: /* Zeros */2,
                                          _1: 2
                                        },
                                        _2: /* No_precision */0,
                                        _3: {
                                          TAG: /* Char_literal */12,
                                          _0: /* ':' */58,
                                          _1: {
                                            TAG: /* Int */4,
                                            _0: /* Int_d */0,
                                            _1: {
                                              TAG: /* Lit_padding */0,
                                              _0: /* Zeros */2,
                                              _1: 2
                                            },
                                            _2: /* No_precision */0,
                                            _3: {
                                              TAG: /* String_literal */11,
                                              _0: " (subsec: ",
                                              _1: {
                                                TAG: /* Int */4,
                                                _0: /* Int_d */0,
                                                _1: /* No_padding */0,
                                                _2: /* No_precision */0,
                                                _3: {
                                                  TAG: /* Char_literal */12,
                                                  _0: /* '/' */47,
                                                  _1: {
                                                    TAG: /* Int */4,
                                                    _0: /* Int_d */0,
                                                    _1: /* No_padding */0,
                                                    _2: /* No_precision */0,
                                                    _3: {
                                                      TAG: /* String_literal */11,
                                                      _0: ") - year out of range (",
                                                      _1: {
                                                        TAG: /* Int */4,
                                                        _0: /* Int_d */0,
                                                        _1: /* No_padding */0,
                                                        _2: /* No_precision */0,
                                                        _3: {
                                                          TAG: /* Char_literal */12,
                                                          _0: /* '-' */45,
                                                          _1: {
                                                            TAG: /* Int */4,
                                                            _0: /* Int_d */0,
                                                            _1: /* No_padding */0,
                                                            _2: /* No_precision */0,
                                                            _3: {
                                                              TAG: /* Char_literal */12,
                                                              _0: /* ')' */41,
                                                              _1: /* End_of_format */0
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "%s.normalize - timestamp cannot be handled: %d-%d-%d %02d:%02d:%02d (subsec: %d/%d) - year out of range (%d-%d)"
                }), [
              "/kxclib.ml/.Datetime0.EpochNormalizedTimestamp",
              yy,
              mm,
              dd,
              hour,
              min,
              sec,
              subsec$1,
              1,
              1970,
              max_year
            ]));
  }
  if (subsec$1 >= 1) {
    Pervasives.invalid_arg(Curry._3(Format.sprintf(/* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ".normalize - subsec out of range (",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* Char_literal */12,
                          _0: /* '-' */45,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* Char_literal */12,
                              _0: /* ')' */41,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "%s.normalize - subsec out of range (%d-%d)"
                }), "/kxclib.ml/.Datetime0.EpochNormalizedTimestamp", 0, 0));
  }
  var ymax = yy - 1 | 0;
  var leaping = yearcount_leaping(1970, ymax);
  var nonleaping = ((ymax - 1970 | 0) + 1 | 0) - leaping | 0;
  var days_past_years = Math.imul(leaping, 366) + Math.imul(nonleaping, 365) | 0;
  var doy = day_of_year(yy)(mm, dd);
  var match = tzoffset !== undefined ? [
      hour + tzoffset[0] | 0,
      min + tzoffset[1] | 0
    ] : [
      hour,
      min
    ];
  var nts = ((sec + Math.imul(match[1], 60) | 0) + Math.imul(Math.imul(match[0], 60), 60) | 0) + Math.imul(Math.imul(Math.imul(days_past_years + doy | 0, 24), 60), 60) | 0;
  return (nts << 0) + subsec$1 | 0;
}

var span$1 = (max_int - 1 | 0) / 1557628928 | 0;

var max_year$1 = (span$1 - 1 | 0) + 1970 | 0;

var Conf$1 = {
  epoch_year: 1970,
  subsecond_resolution: 1000,
  min_year: 1970,
  max_year: max_year$1
};

function yearcount_leaping$1(ymin, ymax) {
  var roundup = function (div, x) {
    if (Caml_int32.mod_(x, div) === 0) {
      return x;
    } else {
      return Math.imul(div, Caml_int32.div(x, div) + 1 | 0);
    }
  };
  var ncat = function (div) {
    var span = ymax - roundup(div, ymin) | 0;
    if (span < 0) {
      return 0;
    } else {
      return Caml_int32.div(span, div) + 1 | 0;
    }
  };
  var ncat4 = ncat(4);
  var ncat100 = ncat(100);
  var ncat400 = ncat(400);
  return (ncat4 - ncat100 | 0) + ncat400 | 0;
}

function normalize$1(subsec, tzoffset, param, param$1) {
  var sec = param$1[2];
  var min = param$1[1];
  var hour = param$1[0];
  var dd = param[2];
  var mm = param[1];
  var yy = param[0];
  var subsec$1 = value(subsec, 0);
  if (yy < 1970 || yy > max_year$1) {
    Pervasives.invalid_arg(Curry.app(Format.asprintf(/* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ".normalize - timestamp cannot be handled: ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* Char_literal */12,
                          _0: /* '-' */45,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* Char_literal */12,
                              _0: /* '-' */45,
                              _1: {
                                TAG: /* Int */4,
                                _0: /* Int_d */0,
                                _1: /* No_padding */0,
                                _2: /* No_precision */0,
                                _3: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ' ' */32,
                                  _1: {
                                    TAG: /* Int */4,
                                    _0: /* Int_d */0,
                                    _1: {
                                      TAG: /* Lit_padding */0,
                                      _0: /* Zeros */2,
                                      _1: 2
                                    },
                                    _2: /* No_precision */0,
                                    _3: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ':' */58,
                                      _1: {
                                        TAG: /* Int */4,
                                        _0: /* Int_d */0,
                                        _1: {
                                          TAG: /* Lit_padding */0,
                                          _0: /* Zeros */2,
                                          _1: 2
                                        },
                                        _2: /* No_precision */0,
                                        _3: {
                                          TAG: /* Char_literal */12,
                                          _0: /* ':' */58,
                                          _1: {
                                            TAG: /* Int */4,
                                            _0: /* Int_d */0,
                                            _1: {
                                              TAG: /* Lit_padding */0,
                                              _0: /* Zeros */2,
                                              _1: 2
                                            },
                                            _2: /* No_precision */0,
                                            _3: {
                                              TAG: /* String_literal */11,
                                              _0: " (subsec: ",
                                              _1: {
                                                TAG: /* Int */4,
                                                _0: /* Int_d */0,
                                                _1: /* No_padding */0,
                                                _2: /* No_precision */0,
                                                _3: {
                                                  TAG: /* Char_literal */12,
                                                  _0: /* '/' */47,
                                                  _1: {
                                                    TAG: /* Int */4,
                                                    _0: /* Int_d */0,
                                                    _1: /* No_padding */0,
                                                    _2: /* No_precision */0,
                                                    _3: {
                                                      TAG: /* String_literal */11,
                                                      _0: ") - year out of range (",
                                                      _1: {
                                                        TAG: /* Int */4,
                                                        _0: /* Int_d */0,
                                                        _1: /* No_padding */0,
                                                        _2: /* No_precision */0,
                                                        _3: {
                                                          TAG: /* Char_literal */12,
                                                          _0: /* '-' */45,
                                                          _1: {
                                                            TAG: /* Int */4,
                                                            _0: /* Int_d */0,
                                                            _1: /* No_padding */0,
                                                            _2: /* No_precision */0,
                                                            _3: {
                                                              TAG: /* Char_literal */12,
                                                              _0: /* ')' */41,
                                                              _1: /* End_of_format */0
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "%s.normalize - timestamp cannot be handled: %d-%d-%d %02d:%02d:%02d (subsec: %d/%d) - year out of range (%d-%d)"
                }), [
              "/kxclib.ml/.Datetime0.EpochNormalizedTimestamp",
              yy,
              mm,
              dd,
              hour,
              min,
              sec,
              subsec$1,
              1000,
              1970,
              max_year$1
            ]));
  }
  if (subsec$1 >= 1000) {
    Pervasives.invalid_arg(Curry._3(Format.sprintf(/* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ".normalize - subsec out of range (",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* Char_literal */12,
                          _0: /* '-' */45,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* Char_literal */12,
                              _0: /* ')' */41,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "%s.normalize - subsec out of range (%d-%d)"
                }), "/kxclib.ml/.Datetime0.EpochNormalizedTimestamp", 0, 999));
  }
  var ymax = yy - 1 | 0;
  var leaping = yearcount_leaping$1(1970, ymax);
  var nonleaping = ((ymax - 1970 | 0) + 1 | 0) - leaping | 0;
  var days_past_years = Math.imul(leaping, 366) + Math.imul(nonleaping, 365) | 0;
  var doy = day_of_year(yy)(mm, dd);
  var match = tzoffset !== undefined ? [
      hour + tzoffset[0] | 0,
      min + tzoffset[1] | 0
    ] : [
      hour,
      min
    ];
  var nts = ((sec + Math.imul(match[1], 60) | 0) + Math.imul(Math.imul(match[0], 60), 60) | 0) + Math.imul(Math.imul(Math.imul(days_past_years + doy | 0, 24), 60), 60) | 0;
  return Math.imul(nts, 1000) + subsec$1 | 0;
}

var span$2 = (max_int - 1 | 0) / -1091436544 | 0;

var max_year$2 = (span$2 - 1 | 0) + 1970 | 0;

var Conf$2 = {
  epoch_year: 1970,
  subsecond_resolution: 1000000000,
  min_year: 1970,
  max_year: max_year$2
};

function yearcount_leaping$2(ymin, ymax) {
  var roundup = function (div, x) {
    if (Caml_int32.mod_(x, div) === 0) {
      return x;
    } else {
      return Math.imul(div, Caml_int32.div(x, div) + 1 | 0);
    }
  };
  var ncat = function (div) {
    var span = ymax - roundup(div, ymin) | 0;
    if (span < 0) {
      return 0;
    } else {
      return Caml_int32.div(span, div) + 1 | 0;
    }
  };
  var ncat4 = ncat(4);
  var ncat100 = ncat(100);
  var ncat400 = ncat(400);
  return (ncat4 - ncat100 | 0) + ncat400 | 0;
}

function normalize$2(subsec, tzoffset, param, param$1) {
  var sec = param$1[2];
  var min = param$1[1];
  var hour = param$1[0];
  var dd = param[2];
  var mm = param[1];
  var yy = param[0];
  var subsec$1 = value(subsec, 0);
  if (yy < 1970 || yy > max_year$2) {
    Pervasives.invalid_arg(Curry.app(Format.asprintf(/* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ".normalize - timestamp cannot be handled: ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* Char_literal */12,
                          _0: /* '-' */45,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* Char_literal */12,
                              _0: /* '-' */45,
                              _1: {
                                TAG: /* Int */4,
                                _0: /* Int_d */0,
                                _1: /* No_padding */0,
                                _2: /* No_precision */0,
                                _3: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ' ' */32,
                                  _1: {
                                    TAG: /* Int */4,
                                    _0: /* Int_d */0,
                                    _1: {
                                      TAG: /* Lit_padding */0,
                                      _0: /* Zeros */2,
                                      _1: 2
                                    },
                                    _2: /* No_precision */0,
                                    _3: {
                                      TAG: /* Char_literal */12,
                                      _0: /* ':' */58,
                                      _1: {
                                        TAG: /* Int */4,
                                        _0: /* Int_d */0,
                                        _1: {
                                          TAG: /* Lit_padding */0,
                                          _0: /* Zeros */2,
                                          _1: 2
                                        },
                                        _2: /* No_precision */0,
                                        _3: {
                                          TAG: /* Char_literal */12,
                                          _0: /* ':' */58,
                                          _1: {
                                            TAG: /* Int */4,
                                            _0: /* Int_d */0,
                                            _1: {
                                              TAG: /* Lit_padding */0,
                                              _0: /* Zeros */2,
                                              _1: 2
                                            },
                                            _2: /* No_precision */0,
                                            _3: {
                                              TAG: /* String_literal */11,
                                              _0: " (subsec: ",
                                              _1: {
                                                TAG: /* Int */4,
                                                _0: /* Int_d */0,
                                                _1: /* No_padding */0,
                                                _2: /* No_precision */0,
                                                _3: {
                                                  TAG: /* Char_literal */12,
                                                  _0: /* '/' */47,
                                                  _1: {
                                                    TAG: /* Int */4,
                                                    _0: /* Int_d */0,
                                                    _1: /* No_padding */0,
                                                    _2: /* No_precision */0,
                                                    _3: {
                                                      TAG: /* String_literal */11,
                                                      _0: ") - year out of range (",
                                                      _1: {
                                                        TAG: /* Int */4,
                                                        _0: /* Int_d */0,
                                                        _1: /* No_padding */0,
                                                        _2: /* No_precision */0,
                                                        _3: {
                                                          TAG: /* Char_literal */12,
                                                          _0: /* '-' */45,
                                                          _1: {
                                                            TAG: /* Int */4,
                                                            _0: /* Int_d */0,
                                                            _1: /* No_padding */0,
                                                            _2: /* No_precision */0,
                                                            _3: {
                                                              TAG: /* Char_literal */12,
                                                              _0: /* ')' */41,
                                                              _1: /* End_of_format */0
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "%s.normalize - timestamp cannot be handled: %d-%d-%d %02d:%02d:%02d (subsec: %d/%d) - year out of range (%d-%d)"
                }), [
              "/kxclib.ml/.Datetime0.EpochNormalizedTimestamp",
              yy,
              mm,
              dd,
              hour,
              min,
              sec,
              subsec$1,
              1000000000,
              1970,
              max_year$2
            ]));
  }
  if (subsec$1 >= 1000000000) {
    Pervasives.invalid_arg(Curry._3(Format.sprintf(/* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ".normalize - subsec out of range (",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* Char_literal */12,
                          _0: /* '-' */45,
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* Char_literal */12,
                              _0: /* ')' */41,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "%s.normalize - subsec out of range (%d-%d)"
                }), "/kxclib.ml/.Datetime0.EpochNormalizedTimestamp", 0, 999999999));
  }
  var ymax = yy - 1 | 0;
  var leaping = yearcount_leaping$2(1970, ymax);
  var nonleaping = ((ymax - 1970 | 0) + 1 | 0) - leaping | 0;
  var days_past_years = Math.imul(leaping, 366) + Math.imul(nonleaping, 365) | 0;
  var doy = day_of_year(yy)(mm, dd);
  var match = tzoffset !== undefined ? [
      hour + tzoffset[0] | 0,
      min + tzoffset[1] | 0
    ] : [
      hour,
      min
    ];
  var nts = ((sec + Math.imul(match[1], 60) | 0) + Math.imul(Math.imul(match[0], 60), 60) | 0) + Math.imul(Math.imul(Math.imul(days_past_years + doy | 0, 24), 60), 60) | 0;
  return Math.imul(nts, 1000000000) + subsec$1 | 0;
}

function Datetime0_EpochNormalizedTimestamp(funarg) {
  var epoch_year = funarg.epoch_year;
  var subsecond_resolution = funarg.subsecond_resolution;
  var min_year = funarg.epoch_year;
  var span = Caml_int32.div(max_int - 1 | 0, Math.imul(31622400, subsecond_resolution));
  var max_year = (span - 1 | 0) + min_year | 0;
  var Conf = {
    epoch_year: epoch_year,
    subsecond_resolution: subsecond_resolution,
    min_year: min_year,
    max_year: max_year
  };
  var yearcount_leaping = function (ymin, ymax) {
    var roundup = function (div, x) {
      if (Caml_int32.mod_(x, div) === 0) {
        return x;
      } else {
        return Math.imul(div, Caml_int32.div(x, div) + 1 | 0);
      }
    };
    var ncat = function (div) {
      var span = ymax - roundup(div, ymin) | 0;
      if (span < 0) {
        return 0;
      } else {
        return Caml_int32.div(span, div) + 1 | 0;
      }
    };
    var ncat4 = ncat(4);
    var ncat100 = ncat(100);
    var ncat400 = ncat(400);
    return (ncat4 - ncat100 | 0) + ncat400 | 0;
  };
  var normalize = function (subsec, tzoffset, param, param$1) {
    var sec = param$1[2];
    var min = param$1[1];
    var hour = param$1[0];
    var dd = param[2];
    var mm = param[1];
    var yy = param[0];
    var subsec$1 = value(subsec, 0);
    if (yy < min_year || yy > max_year) {
      Pervasives.invalid_arg(Curry.app(Format.asprintf(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ".normalize - timestamp cannot be handled: ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* Char_literal */12,
                            _0: /* '-' */45,
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* Char_literal */12,
                                _0: /* '-' */45,
                                _1: {
                                  TAG: /* Int */4,
                                  _0: /* Int_d */0,
                                  _1: /* No_padding */0,
                                  _2: /* No_precision */0,
                                  _3: {
                                    TAG: /* Char_literal */12,
                                    _0: /* ' ' */32,
                                    _1: {
                                      TAG: /* Int */4,
                                      _0: /* Int_d */0,
                                      _1: {
                                        TAG: /* Lit_padding */0,
                                        _0: /* Zeros */2,
                                        _1: 2
                                      },
                                      _2: /* No_precision */0,
                                      _3: {
                                        TAG: /* Char_literal */12,
                                        _0: /* ':' */58,
                                        _1: {
                                          TAG: /* Int */4,
                                          _0: /* Int_d */0,
                                          _1: {
                                            TAG: /* Lit_padding */0,
                                            _0: /* Zeros */2,
                                            _1: 2
                                          },
                                          _2: /* No_precision */0,
                                          _3: {
                                            TAG: /* Char_literal */12,
                                            _0: /* ':' */58,
                                            _1: {
                                              TAG: /* Int */4,
                                              _0: /* Int_d */0,
                                              _1: {
                                                TAG: /* Lit_padding */0,
                                                _0: /* Zeros */2,
                                                _1: 2
                                              },
                                              _2: /* No_precision */0,
                                              _3: {
                                                TAG: /* String_literal */11,
                                                _0: " (subsec: ",
                                                _1: {
                                                  TAG: /* Int */4,
                                                  _0: /* Int_d */0,
                                                  _1: /* No_padding */0,
                                                  _2: /* No_precision */0,
                                                  _3: {
                                                    TAG: /* Char_literal */12,
                                                    _0: /* '/' */47,
                                                    _1: {
                                                      TAG: /* Int */4,
                                                      _0: /* Int_d */0,
                                                      _1: /* No_padding */0,
                                                      _2: /* No_precision */0,
                                                      _3: {
                                                        TAG: /* String_literal */11,
                                                        _0: ") - year out of range (",
                                                        _1: {
                                                          TAG: /* Int */4,
                                                          _0: /* Int_d */0,
                                                          _1: /* No_padding */0,
                                                          _2: /* No_precision */0,
                                                          _3: {
                                                            TAG: /* Char_literal */12,
                                                            _0: /* '-' */45,
                                                            _1: {
                                                              TAG: /* Int */4,
                                                              _0: /* Int_d */0,
                                                              _1: /* No_padding */0,
                                                              _2: /* No_precision */0,
                                                              _3: {
                                                                TAG: /* Char_literal */12,
                                                                _0: /* ')' */41,
                                                                _1: /* End_of_format */0
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "%s.normalize - timestamp cannot be handled: %d-%d-%d %02d:%02d:%02d (subsec: %d/%d) - year out of range (%d-%d)"
                  }), [
                "/kxclib.ml/.Datetime0.EpochNormalizedTimestamp",
                yy,
                mm,
                dd,
                hour,
                min,
                sec,
                subsec$1,
                subsecond_resolution,
                min_year,
                max_year
              ]));
    }
    if (subsec$1 >= subsecond_resolution) {
      Pervasives.invalid_arg(Curry._3(Format.sprintf(/* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ".normalize - subsec out of range (",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* Char_literal */12,
                            _0: /* '-' */45,
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* Char_literal */12,
                                _0: /* ')' */41,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "%s.normalize - subsec out of range (%d-%d)"
                  }), "/kxclib.ml/.Datetime0.EpochNormalizedTimestamp", 0, subsecond_resolution - 1 | 0));
    }
    var ymax = yy - 1 | 0;
    var leaping = yearcount_leaping(epoch_year, ymax);
    var nonleaping = ((ymax - epoch_year | 0) + 1 | 0) - leaping | 0;
    var days_past_years = Math.imul(leaping, 366) + Math.imul(nonleaping, 365) | 0;
    var doy = day_of_year(yy)(mm, dd);
    var match = tzoffset !== undefined ? [
        hour + tzoffset[0] | 0,
        min + tzoffset[1] | 0
      ] : [
        hour,
        min
      ];
    var nts = ((sec + Math.imul(match[1], 60) | 0) + Math.imul(Math.imul(match[0], 60), 60) | 0) + Math.imul(Math.imul(Math.imul(days_past_years + doy | 0, 24), 60), 60) | 0;
    return Math.imul(nts, subsecond_resolution) + subsec$1 | 0;
  };
  return {
          Conf: Conf,
          normalize: normalize
        };
}

var Datetime0_UnixTimestmapSecRes = {
  Conf: Conf,
  normalize: normalize
};

var Datetime0_UnixTimestmapMilliRes = {
  Conf: Conf$1,
  normalize: normalize$1
};

var Datetime0_UnixTimestmapNanoRes = {
  Conf: Conf$2,
  normalize: normalize$2
};

var Datetime0 = {
  leap_year: leap_year,
  daycount_of_month: daycount_of_month,
  day_of_year: day_of_year,
  EpochNormalizedTimestamp: Datetime0_EpochNormalizedTimestamp,
  UnixTimestmapSecRes: Datetime0_UnixTimestmapSecRes,
  UnixTimestmapMilliRes: Datetime0_UnixTimestmapMilliRes,
  UnixTimestmapNanoRes: Datetime0_UnixTimestmapNanoRes
};

function prefset(r, x) {
  r.contents = x;
  
}

function prefsetv(r, v, param) {
  r.contents = v;
  
}

function scanfparser(fmt, fn, str) {
  Curry._1(Scanf.ksscanf(str, (function (param, param$1) {
              return {
                      NAME: "Process_next",
                      VAL: true
                    };
            }), fmt), fn);
  return {
          NAME: "Process_next",
          VAL: false
        };
}

function exactparser(fmt, fn, str) {
  if (str === fmt) {
    Curry._1(fn, undefined);
    return {
            NAME: "Process_next",
            VAL: false
          };
  } else {
    return {
            NAME: "Process_next",
            VAL: true
          };
  }
}

function parse_opts(optparsers, argsourceOpt, param) {
  var argsource = argsourceOpt !== undefined ? argsourceOpt : [
      Sys.argv,
      1
    ];
  var f = function (param) {
    var _param = optparsers;
    while(true) {
      var param$1 = _param;
      if (param$1) {
        var match = Curry._1(param$1.hd, param);
        if (!match.VAL) {
          return ;
        }
        _param = param$1.tl;
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "unparsed option: " + param,
            Error: new Error()
          };
    };
  };
  var xs = ntimes(argsource[1], tl$2, to_list$1(argsource[0]));
  return Belt_List.forEach(xs, f);
}

function parse_opts_args(optprefixOpt, optsepOpt, optparsers, argsourceOpt, param) {
  var optprefix = optprefixOpt !== undefined ? optprefixOpt : "-";
  var optsep = optsepOpt !== undefined ? optsepOpt : "--";
  var argsource = argsourceOpt !== undefined ? argsourceOpt : [
      Sys.argv,
      1
    ];
  var source = argsource[0];
  var optprefixlen = optprefix.length;
  var prefixed = function (str) {
    if (str.length < optprefixlen) {
      return false;
    } else {
      return $$String.sub(str, 0, optprefixlen) === optprefix;
    }
  };
  var argc = source.length;
  var args = {
    contents: /* [] */0
  };
  var tryparse = function (str, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var match = Curry._1(param.hd, str);
        if (!match.VAL) {
          return ;
        }
        _param = param.tl;
        continue ;
      }
      throw {
            RE_EXN_ID: "Invalid_argument",
            _1: "unparsed option: " + str,
            Error: new Error()
          };
    };
  };
  var _n = argsource[1];
  var _parseopt = true;
  while(true) {
    var parseopt = _parseopt;
    var n = _n;
    if (n >= argc) {
      return Belt_List.reverse(args.contents);
    }
    var arg = Belt_Array.getExn(source, n);
    if (parseopt) {
      if (arg === optsep) {
        _parseopt = false;
        _n = n + 1 | 0;
        continue ;
      }
      if (prefixed(arg)) {
        tryparse(arg, optparsers);
        _n = n + 1 | 0;
        continue ;
      }
      refappend(args, arg);
      _n = n + 1 | 0;
      continue ;
    }
    refappend(args, arg);
    _n = n + 1 | 0;
    continue ;
  };
}

var ParseArgs = {
  prefset: prefset,
  prefsetv: prefsetv,
  scanfparser: scanfparser,
  exactparser: exactparser,
  parse_opts: parse_opts,
  parse_opts_args: parse_opts_args
};

function opt_of_named_option(opt) {
  return opt._0;
}

function has_flag(argsource, prefixOpt, flag) {
  var prefix = prefixOpt !== undefined ? prefixOpt : "";
  var store = {
    contents: false
  };
  var partial_arg = prefix + flag;
  var partial_arg$1 = {
    NAME: "Process_next",
    VAL: false
  };
  parse_opts({
        hd: (function (param) {
            return exactparser(partial_arg, (function (param) {
                          store.contents = true;
                          
                        }), param);
          }),
        tl: {
          hd: (function (param) {
              return partial_arg$1;
            }),
          tl: /* [] */0
        }
      }, argsource, undefined);
  return store.contents;
}

function get_option(argsource, prefixOpt, optsep) {
  var prefix = prefixOpt !== undefined ? prefixOpt : "";
  var labor = function (opt, f) {
    var state = {
      contents: "Init"
    };
    var result = {
      contents: undefined
    };
    var marker_raw = prefix + opt;
    var marker_eq = marker_raw + "=";
    var par = function (arg) {
      var match = state.contents;
      if (match === "CaptureNext") {
        state.contents = "Init";
        result.contents = Caml_option.some(Curry._1(f, arg));
        return {
                NAME: "Process_next",
                VAL: false
              };
      }
      if (arg === marker_raw) {
        state.contents = "CaptureNext";
        return {
                NAME: "Process_next",
                VAL: true
              };
      }
      var arg$1 = chop_prefix(marker_eq)(arg);
      if (arg$1 !== undefined) {
        result.contents = Caml_option.some(Curry._1(f, arg$1));
        return {
                NAME: "Process_next",
                VAL: false
              };
      } else {
        return {
                NAME: "Process_next",
                VAL: true
              };
      }
    };
    var partial_arg = {
      NAME: "Process_next",
      VAL: false
    };
    parse_opts_args("", optsep, {
          hd: par,
          tl: {
            hd: (function (param) {
                return partial_arg;
              }),
            tl: /* [] */0
          }
        }, argsource, undefined);
    var match = state.contents;
    if (match === "CaptureNext") {
      return Pervasives.invalid_arg("no argument supplied to option " + opt);
    } else {
      return result.contents;
    }
  };
  return function (opt) {
    switch (opt.TAG | 0) {
      case /* IntOption */0 :
          return labor(opt._0, (function (arg) {
                        return Curry._1(Scanf.sscanf(arg, /* Format */{
                                        _0: {
                                          TAG: /* Int */4,
                                          _0: /* Int_i */3,
                                          _1: /* No_padding */0,
                                          _2: /* No_precision */0,
                                          _3: {
                                            TAG: /* Flush */10,
                                            _0: /* End_of_format */0
                                          }
                                        },
                                        _1: "%i%!"
                                      }), identity);
                      }));
      case /* FloatOption */1 :
          return labor(opt._0, (function (arg) {
                        return Curry._1(Scanf.sscanf(arg, /* Format */{
                                        _0: {
                                          TAG: /* Float */8,
                                          _0: /* Float_g */9,
                                          _1: /* No_padding */0,
                                          _2: /* No_precision */0,
                                          _3: {
                                            TAG: /* Flush */10,
                                            _0: /* End_of_format */0
                                          }
                                        },
                                        _1: "%g%!"
                                      }), identity);
                      }));
      case /* StringOption */2 :
          return labor(opt._0, identity);
      case /* InChannelOption */3 :
          return labor(opt._0, (function (path) {
                        if (path === "-") {
                          return Pervasives.stdin;
                        } else {
                          return Pervasives.open_in(path);
                        }
                      }));
      case /* OutChannelOption */4 :
          return labor(opt._0, (function (path) {
                        if (path === "-") {
                          return Pervasives.stdout;
                        } else {
                          return Pervasives.open_out(path);
                        }
                      }));
      case /* InChannelOption' */5 :
          return labor(opt._0, (function (path) {
                        if (path === "-") {
                          return [
                                  Pervasives.stdin,
                                  "StandardChannel"
                                ];
                        } else {
                          return [
                                  Pervasives.open_in(path),
                                  {
                                    NAME: "FileChannel",
                                    VAL: path
                                  }
                                ];
                        }
                      }));
      case /* OutChannelOption' */6 :
          return labor(opt._0, (function (path) {
                        if (path === "-") {
                          return [
                                  Pervasives.stdout,
                                  "StandardChannel"
                                ];
                        } else {
                          return [
                                  Pervasives.open_out(path),
                                  {
                                    NAME: "FileChannel",
                                    VAL: path
                                  }
                                ];
                        }
                      }));
      
    }
  };
}

function get_option_exn(argsource, prefix, optsep, opt) {
  var x = get_option(argsource, prefix, optsep)(opt);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return Pervasives.invalid_arg("you have to provide option " + opt._0);
  }
}

function get_option_d$p(argsource, prefix, optsep, opt, vp) {
  var x = get_option(argsource, prefix, optsep)(opt);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return Curry._1(vp, undefined);
  }
}

function get_option_d(argsource, prefix, optsep, opt, v) {
  var x = get_option(argsource, prefix, optsep)(opt);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return v;
  }
}

function get_absolute_args(optsepOpt, argsourceOpt, param) {
  var optsep = optsepOpt !== undefined ? optsepOpt : "--";
  var argsource = argsourceOpt !== undefined ? argsourceOpt : [
      Sys.argv,
      1
    ];
  var source = argsource[0];
  var argc = source.length;
  var args = {
    contents: /* [] */0
  };
  var _n = argsource[1];
  var _record_arg = false;
  while(true) {
    var record_arg = _record_arg;
    var n = _n;
    if (n >= argc) {
      return Belt_List.reverse(args.contents);
    }
    var arg = Belt_Array.getExn(source, n);
    if (record_arg) {
      refappend(args, arg);
      _n = n + 1 | 0;
      continue ;
    }
    if (arg === optsep) {
      _record_arg = true;
      _n = n + 1 | 0;
      continue ;
    }
    _n = n + 1 | 0;
    continue ;
  };
}

var ArgOptions = {
  opt_of_named_option: opt_of_named_option,
  has_flag: has_flag,
  get_option: get_option,
  get_option_exn: get_option_exn,
  get_option_d$p: get_option_d$p,
  get_option_d: get_option_d,
  get_absolute_args: get_absolute_args
};

var color_enabled = {
  contents: true
};

var fprintf = Format.fprintf;

var printf = Format.printf;

var sprintf = Format.asprintf;

var eprintf = Format.eprintf;

var null_ppf = Format.formatter_of_out_functions({
      out_string: (function (param, param$1, param$2) {
          
        }),
      out_flush: (function (param) {
          
        }),
      out_newline: (function (param) {
          
        }),
      out_spaces: (function (param) {
          
        }),
      out_indent: (function (param) {
          
        })
    });

function colored(style, mOpt, color, ppf, fmt) {
  var m = mOpt !== undefined ? mOpt : "Fg";
  if (!color_enabled.contents) {
    return Format.fprintf(ppf, fmt);
  }
  var code_table = function (param) {
    if (param === "Bright_red") {
      return [
              91,
              101
            ];
    } else if (param === "Bright_yellow") {
      return [
              93,
              103
            ];
    } else if (param === "Bright_black") {
      return [
              90,
              100
            ];
    } else if (param === "Magenta") {
      return [
              35,
              45
            ];
    } else if (param === "White") {
      return [
              37,
              47
            ];
    } else if (param === "Red") {
      return [
              31,
              41
            ];
    } else if (param === "Yellow") {
      return [
              33,
              43
            ];
    } else if (param === "Bright_magenta") {
      return [
              95,
              105
            ];
    } else if (param === "Bright_blue") {
      return [
              94,
              104
            ];
    } else if (param === "Bright_cyan") {
      return [
              96,
              106
            ];
    } else if (param === "Blue") {
      return [
              34,
              44
            ];
    } else if (param === "Cyan") {
      return [
              36,
              46
            ];
    } else if (param === "Green") {
      return [
              32,
              42
            ];
    } else if (param === "Bright_green") {
      return [
              92,
              102
            ];
    } else {
      return [
              30,
              40
            ];
    }
  };
  var style_table = function (param) {
    if (param === "Bold") {
      return 1;
    } else if (param === "Thin") {
      return 2;
    } else if (param === "Italic") {
      return 3;
    } else {
      return 4;
    }
  };
  var esc = function (x) {
    return "\x1b" + x;
  };
  var color_code = Curry._1(Format.asprintf(/* Format */{
            _0: {
              TAG: /* Char_literal */12,
              _0: /* '[' */91,
              _1: {
                TAG: /* Int */4,
                _0: /* Int_d */0,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* 'm' */109,
                  _1: /* End_of_format */0
                }
              }
            },
            _1: "[%dm"
          }), (
          m === "Fg" ? (function (prim) {
                return prim[0];
              }) : (function (prim) {
                return prim[1];
              })
        )(code_table(color)));
  var style_code = style !== undefined ? Caml_option.some(Curry._1(Format.asprintf(/* Format */{
                  _0: {
                    TAG: /* Char_literal */12,
                    _0: /* '[' */91,
                    _1: {
                      TAG: /* Int */4,
                      _0: /* Int_d */0,
                      _1: /* No_padding */0,
                      _2: /* No_precision */0,
                      _3: {
                        TAG: /* Char_literal */12,
                        _0: /* 'm' */109,
                        _1: /* End_of_format */0
                      }
                    }
                  },
                  _1: "[%dm"
                }), style_table(style))) : undefined;
  var o = map$1(esc, style_code);
  Curry._1(Format.fprintf(ppf, /* Format */{
            _0: {
              TAG: /* Formatting_lit */17,
              _0: {
                TAG: /* Magic_size */1,
                _0: "@<0>",
                _1: 0
              },
              _1: {
                TAG: /* String */2,
                _0: /* No_padding */0,
                _1: /* End_of_format */0
              }
            },
            _1: "@<0>%s"
          }), "\x1b" + color_code + v("", o));
  return Format.kfprintf((function (ppf) {
                return Curry._1(Format.fprintf(ppf, /* Format */{
                                _0: {
                                  TAG: /* Formatting_lit */17,
                                  _0: {
                                    TAG: /* Magic_size */1,
                                    _0: "@<0>",
                                    _1: 0
                                  },
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: /* End_of_format */0
                                  }
                                },
                                _1: "@<0>%s"
                              }), "\x1b[0m");
              }), ppf, fmt);
}

var Fmt = {
  stdout_ppf: Format.std_formatter,
  stderr_ppf: Format.err_formatter,
  null_ppf: null_ppf,
  colored: colored
};

function condformat(cond, fmtfunc, fmt) {
  if (cond) {
    return Curry._1(fmtfunc, fmt);
  } else {
    return Format.ifprintf(null_ppf, fmt);
  }
}

function pp_of_to_string(to_string, ppf, x) {
  return Format.pp_print_string(ppf, Curry._1(to_string, x));
}

function to_string_of_pp(pp) {
  return Curry._1(Format.asprintf(/* Format */{
                  _0: {
                    TAG: /* Alpha */15,
                    _0: /* End_of_format */0
                  },
                  _1: "%a"
                }), pp);
}

function pps(to_string) {
  return function (param, param$1) {
    return Format.pp_print_string(param, Curry._1(to_string, param$1));
  };
}

function spp(pp) {
  return Curry._1(Format.asprintf(/* Format */{
                  _0: {
                    TAG: /* Alpha */15,
                    _0: /* End_of_format */0
                  },
                  _1: "%a"
                }), pp);
}

function pp_unit(ppf, param) {
  return Format.pp_print_string(ppf, "unit");
}

function pp_ref_address(ppf, r) {
  return Curry._1(Format.fprintf(ppf, /* Format */{
                  _0: {
                    TAG: /* Int */4,
                    _0: /* Int_Cx */7,
                    _1: /* No_padding */0,
                    _2: /* No_precision */0,
                    _3: /* End_of_format */0
                  },
                  _1: "%#x"
                }), (r << 1));
}

function pp_int32(ppf, x) {
  return Format.pp_print_string(ppf, Int32.to_string(x));
}

function pp_int64(ppf, x) {
  return Format.pp_print_string(ppf, Int64.to_string(x));
}

function pp_integer_sep$p(padding, ppf, x) {
  var loop = function (_acc, _x) {
    while(true) {
      var x = _x;
      var acc = _acc;
      if (x <= 0) {
        return acc;
      }
      _x = x / 1000 | 0;
      _acc = {
        hd: x % 1000,
        tl: acc
      };
      continue ;
    };
  };
  var chunks = loop(/* [] */0, Pervasives.abs(x));
  var chunks$1;
  if (chunks) {
    var r = chunks.tl;
    var x$1 = chunks.hd;
    if (r) {
      var f = Format.asprintf(/* Format */{
            _0: {
              TAG: /* Int */4,
              _0: /* Int_d */0,
              _1: {
                TAG: /* Lit_padding */0,
                _0: /* Zeros */2,
                _1: 3
              },
              _2: /* No_precision */0,
              _3: /* End_of_format */0
            },
            _1: "%03d"
          });
      chunks$1 = {
        hd: String(x$1),
        tl: Belt_List.map(r, f)
      };
    } else {
      chunks$1 = {
        hd: String(x$1),
        tl: /* [] */0
      };
    }
  } else {
    chunks$1 = {
      hd: "0",
      tl: /* [] */0
    };
  }
  if (x < 0) {
    Format.pp_print_char(ppf, /* '-' */45);
  }
  var str = $$String.concat(",", chunks$1);
  if (padding !== undefined) {
    var d = padding[0];
    if (d !== 0) {
      var pad = padding[1];
      var d$1 = (d + (Math.ceil(d / 3) | 0) | 0) - 1 | 0;
      var slen = str.length;
      if (d$1 > slen) {
        ntimes(d$1 - slen | 0, (function (param) {
                return Format.pp_print_char(ppf, pad);
              }), undefined);
      }
      
    }
    
  }
  return Format.pp_print_string(ppf, str);
}

function pp_integer_sep(ppf) {
  return function (param) {
    return pp_integer_sep$p(undefined, ppf, param);
  };
}

function pp_multiline(ppf, str) {
  var _param = $$String.split_on_char(/* '\n' */10, str);
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    var rest = param.tl;
    var line = param.hd;
    if (!rest) {
      return Format.pp_print_string(ppf, line);
    }
    Format.pp_print_string(ppf, line);
    Format.pp_force_newline(ppf, undefined);
    _param = rest;
    continue ;
  };
}

function pp_exn(ppf, exn) {
  return Format.pp_print_string(ppf, Printexc.to_string(exn));
}

function pp_full_exn$p(ppf, param) {
  return Curry._3(Format.fprintf(ppf, /* Format */{
                  _0: {
                    TAG: /* Formatting_lit */17,
                    _0: {
                      TAG: /* Magic_size */1,
                      _0: "@<2>",
                      _1: 2
                    },
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Formatting_gen */18,
                        _0: {
                          TAG: /* Open_box */1,
                          _0: /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "<hov>",
                              _1: /* End_of_format */0
                            },
                            _1: "<hov>"
                          }
                        },
                        _1: {
                          TAG: /* Formatting_lit */17,
                          _0: /* Force_newline */3,
                          _1: {
                            TAG: /* Alpha */15,
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: /* Close_box */0,
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "@<2>%s@[<hov>@\n%a@]"
                }), Printexc.to_string(param[0]), pp_multiline, $$String.concat("\n", param[1]));
}

function pp_full_exn(ppf, exn) {
  return pp_full_exn$p(ppf, [
              exn,
              get_raw_backtrace(undefined)
            ]);
}

function string_of_symbolic_output_items(items) {
  var buf = create$1(0);
  Belt_List.forEach(items, (function (str) {
          if (typeof str === "number") {
            if (str === /* Output_flush */0) {
              return ;
            } else {
              return add_char(buf, /* '\n' */10);
            }
          }
          switch (str.TAG | 0) {
            case /* Output_string */0 :
                return add_string(buf, str._0);
            case /* Output_spaces */1 :
            case /* Output_indent */2 :
                return add_string(buf, $$String.make(str._0, /* ' ' */32));
            
          }
        }));
  return contents(buf);
}

var FmtPervasives = {
  color_enabled: color_enabled,
  fprintf: fprintf,
  printf: printf,
  sprintf: sprintf,
  eprintf: eprintf,
  Fmt: Fmt,
  condformat: condformat,
  pp_of_to_string: pp_of_to_string,
  to_string_of_pp: to_string_of_pp,
  pps: pps,
  spp: spp,
  pp_int: Format.pp_print_int,
  pp_float: Format.pp_print_float,
  pp_string: Format.pp_print_string,
  pp_char: Format.pp_print_char,
  pp_bool: Format.pp_print_bool,
  pp_unit: pp_unit,
  pp_ref_address: pp_ref_address,
  pp_int32: pp_int32,
  pp_int64: pp_int64,
  pp_integer_sep$p: pp_integer_sep$p,
  pp_integer_sep: pp_integer_sep,
  pp_multiline: pp_multiline,
  pp_exn: pp_exn,
  pp_full_exn$p: pp_full_exn$p,
  pp_full_exn: pp_full_exn,
  string_of_symbolic_output_items: string_of_symbolic_output_items
};

var timestamp_func = {
  contents: (function (param) {
      
    })
};

var logging_formatter = {
  contents: Format.err_formatter
};

var Internals$1 = {
  timestamp_func: timestamp_func,
  logging_formatter: logging_formatter
};

function install_timestamp_function(func) {
  timestamp_func.contents = func;
  
}

function set_logging_formatter(ppf) {
  logging_formatter.contents = ppf;
  
}

function get_logging_formatter(param) {
  return logging_formatter.contents;
}

var LoggingConfig = {
  install_timestamp_function: install_timestamp_function,
  set_logging_formatter: set_logging_formatter,
  get_logging_formatter: get_logging_formatter
};

function logr(fmt) {
  return Format.fprintf(logging_formatter.contents, fmt);
}

function log(label, modul, styleOpt, colorOpt, fmt) {
  var style = styleOpt !== undefined ? Caml_option.valFromOption(styleOpt) : undefined;
  var color = colorOpt !== undefined ? colorOpt : "Magenta";
  var header = modul !== undefined ? label + (":" + modul) : label;
  var ts = Curry._1(timestamp_func.contents, undefined);
  var header$1 = ts !== undefined ? Curry._2(Format.sprintf(/* Format */{
              _0: {
                TAG: /* Char_literal */12,
                _0: /* '[' */91,
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* String_literal */11,
                    _0: " :",
                    _1: {
                      TAG: /* Float */8,
                      _0: /* Float_f */0,
                      _1: /* No_padding */0,
                      _2: /* Lit_precision */{
                        _0: 3
                      },
                      _3: {
                        TAG: /* Char_literal */12,
                        _0: /* ']' */93,
                        _1: /* End_of_format */0
                      }
                    }
                  }
                }
              },
              _1: "[%s :%.3f]"
            }), header, ts) : Curry._1(Format.sprintf(/* Format */{
              _0: {
                TAG: /* Char_literal */12,
                _0: /* '[' */91,
                _1: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: {
                    TAG: /* Char_literal */12,
                    _0: /* ']' */93,
                    _1: /* End_of_format */0
                  }
                }
              },
              _1: "[%s]"
            }), header);
  var pp_header = function (ppf) {
    return colored(style, undefined, color, ppf, /* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              });
  };
  Curry._1(Format.fprintf(logging_formatter.contents, /* Format */{
            _0: {
              TAG: /* Formatting_lit */17,
              _0: {
                TAG: /* Magic_size */1,
                _0: "@<1>",
                _1: 1
              },
              _1: {
                TAG: /* String */2,
                _0: /* No_padding */0,
                _1: {
                  TAG: /* Char_literal */12,
                  _0: /* ' ' */32,
                  _1: {
                    TAG: /* Formatting_gen */18,
                    _0: {
                      TAG: /* Open_box */1,
                      _0: /* Format */{
                        _0: {
                          TAG: /* String_literal */11,
                          _0: "<hov>",
                          _1: /* End_of_format */0
                        },
                        _1: "<hov>"
                      }
                    },
                    _1: /* End_of_format */0
                  }
                }
              }
            },
            _1: "@<1>%s @[<hov>"
          }), Curry._2(Format.asprintf(/* Format */{
                _0: {
                  TAG: /* Alpha */15,
                  _0: /* End_of_format */0
                },
                _1: "%a"
              }), pp_header, header$1));
  return Format.kfprintf((function (ppf) {
                return Format.fprintf(ppf, /* Format */{
                            _0: {
                              TAG: /* Formatting_lit */17,
                              _0: /* Close_box */0,
                              _1: {
                                TAG: /* Formatting_lit */17,
                                _0: /* Flush_newline */4,
                                _1: /* End_of_format */0
                              }
                            },
                            _1: "@]@."
                          });
              }), logging_formatter.contents, fmt);
}

function verbose(modul, fmt) {
  return log("VERBOSE", modul, "Thin", "Bright_cyan", fmt);
}

function info(modul, fmt) {
  return log("INFO", modul, "Bold", "Bright_cyan", fmt);
}

function warn(modul, fmt) {
  return log("WARN", modul, "Bold", "Yellow", fmt);
}

function debug(modul, fmt) {
  return log("DEBUG", modul, "Bold", "Magenta", fmt);
}

function error$1(modul, fmt) {
  return log("ERROR", modul, "Bold", "Red", fmt);
}

var debug$1 = debug;

var info$1 = info;

var Pervasives$1 = {
  debug: debug$1,
  info: info$1
};

var Log0 = {
  Internals: Internals$1,
  LoggingConfig: LoggingConfig,
  logr: logr,
  log: log,
  verbose: verbose,
  info: info,
  warn: warn,
  debug: debug,
  error: error$1,
  Pervasives: Pervasives$1
};

function of_legacy(x) {
  return x;
}

function to_legacy(x) {
  if (typeof x !== "object") {
    return ;
  }
  var variant = x.NAME;
  if (variant === "obj" || variant === "arr") {
    return x;
  }
  
}

function of_yojson(param) {
  if (typeof param !== "object") {
    return "null";
  }
  var variant = param.NAME;
  if (variant === "Intlit") {
    return {
            NAME: "num",
            VAL: Caml_format.caml_float_of_string(param.VAL)
          };
  }
  if (variant === "Int") {
    return {
            NAME: "num",
            VAL: param.VAL
          };
  }
  if (variant === "Float") {
    return {
            NAME: "num",
            VAL: param.VAL
          };
  }
  if (variant === "Variant") {
    var match = param.VAL;
    var x = match[1];
    var t = match[0];
    if (x !== undefined) {
      return {
              NAME: "arr",
              VAL: {
                hd: {
                  NAME: "str",
                  VAL: t
                },
                tl: {
                  hd: of_yojson(x),
                  tl: /* [] */0
                }
              }
            };
    } else {
      return {
              NAME: "str",
              VAL: t
            };
    }
  }
  if (variant === "List" || variant === "Tuple") {
    return {
            NAME: "arr",
            VAL: Belt_List.map(param.VAL, of_yojson)
          };
  }
  if (variant === "Bool") {
    return {
            NAME: "bool",
            VAL: param.VAL
          };
  }
  if (variant !== "Assoc") {
    return {
            NAME: "str",
            VAL: param.VAL
          };
  }
  var f = function (param) {
    return $question$great(of_yojson, param);
  };
  return {
          NAME: "obj",
          VAL: Belt_List.map(param.VAL, f)
        };
}

function to_yojson(param) {
  if (typeof param !== "object") {
    return "Null";
  }
  var variant = param.NAME;
  if (variant === "arr") {
    return {
            NAME: "List",
            VAL: Belt_List.map(param.VAL, to_yojson)
          };
  }
  if (variant === "num") {
    var x = param.VAL;
    if (Number.isInteger(x) && x <= max_int && x >= min_int) {
      return {
              NAME: "Int",
              VAL: x
            };
    } else {
      return {
              NAME: "Float",
              VAL: x
            };
    }
  }
  if (variant !== "obj") {
    if (variant === "str") {
      return {
              NAME: "String",
              VAL: param.VAL
            };
    } else {
      return {
              NAME: "Bool",
              VAL: param.VAL
            };
    }
  }
  var f = function (param) {
    return $question$great(to_yojson, param);
  };
  return {
          NAME: "Assoc",
          VAL: Belt_List.map(param.VAL, f)
        };
}

function yojson_basic_of_safe(yojson) {
  if (typeof yojson !== "object") {
    return "Null";
  }
  var variant = yojson.NAME;
  if (variant === "Intlit") {
    return {
            NAME: "Int",
            VAL: Caml_format.caml_int_of_string(yojson.VAL)
          };
  }
  if (variant === "Int") {
    return {
            NAME: "Int",
            VAL: yojson.VAL
          };
  }
  if (variant === "Float") {
    return {
            NAME: "Float",
            VAL: yojson.VAL
          };
  }
  if (variant !== "Variant") {
    if (variant === "List" || variant === "Tuple") {
      return {
              NAME: "List",
              VAL: Belt_List.map(yojson.VAL, yojson_basic_of_safe)
            };
    } else if (variant === "Bool") {
      return {
              NAME: "Bool",
              VAL: yojson.VAL
            };
    } else if (variant === "Assoc") {
      return {
              NAME: "Assoc",
              VAL: Belt_List.map(yojson.VAL, (function (param) {
                      return [
                              param[0],
                              yojson_basic_of_safe(param[1])
                            ];
                    }))
            };
    } else {
      return {
              NAME: "String",
              VAL: yojson.VAL
            };
    }
  }
  var match = yojson.VAL;
  var c = match[0];
  var x = map$1(yojson_basic_of_safe, match[1]);
  if (x !== undefined) {
    return {
            NAME: "List",
            VAL: {
              hd: {
                NAME: "String",
                VAL: c
              },
              tl: {
                hd: x,
                tl: /* [] */0
              }
            }
          };
  } else {
    return {
            NAME: "List",
            VAL: {
              hd: {
                NAME: "String",
                VAL: c
              },
              tl: /* [] */0
            }
          };
  }
}

function yojson_safe_of_basic(x) {
  return x;
}

function of_jsonm$p(input) {
  var jv_of_atom = function (param) {
    if (typeof param !== "object") {
      return "null";
    }
    var variant = param.NAME;
    if (variant === "Float") {
      return {
              NAME: "num",
              VAL: param.VAL
            };
    } else if (variant === "Bool") {
      return {
              NAME: "bool",
              VAL: param.VAL
            };
    } else {
      return {
              NAME: "str",
              VAL: param.VAL
            };
    }
  };
  var with_next = function (sloc, next, kont) {
    var match = Curry._1(next, undefined);
    if (!match) {
      return {
              TAG: /* Error */1,
              _0: {
                NAME: "premature_end",
                VAL: sloc
              }
            };
    }
    var match$1 = match._0;
    return Curry._3(kont, match$1[0], match._1, match$1[1]);
  };
  var value = function (loc, next, tok) {
    if (typeof tok === "object") {
      if (tok.NAME === "Name") {
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "unexpected_token_at",
                  VAL: [
                    loc,
                    tok
                  ]
                }
              };
      }
      var x = jv_of_atom(tok);
      return {
              TAG: /* Ok */0,
              _0: [
                x,
                next
              ]
            };
    }
    if (tok === "As") {
      return with_next(loc, next, (function (param, param$1, param$2) {
                    return collect_array(/* [] */0, param, param$1, param$2);
                  }));
    }
    if (tok === "Os") {
      return with_next(loc, next, (function (param, param$1, param$2) {
                    return collect_object(/* [] */0, param, param$1, param$2);
                  }));
    }
    if (tok !== "Null") {
      return {
              TAG: /* Error */1,
              _0: {
                NAME: "unexpected_token_at",
                VAL: [
                  loc,
                  tok
                ]
              }
            };
    }
    var x$1 = jv_of_atom(tok);
    return {
            TAG: /* Ok */0,
            _0: [
              x$1,
              next
            ]
          };
  };
  var collect_array = function (acc, sloc, next, tok) {
    if (typeof tok === "object") {
      if (tok.NAME === "Name") {
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "unexpected_token_at",
                  VAL: [
                    sloc,
                    tok
                  ]
                }
              };
      }
      
    } else if (!(tok === "Null" || tok === "Os" || tok === "As")) {
      if (tok === "Oe") {
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "unexpected_token_at",
                  VAL: [
                    sloc,
                    tok
                  ]
                }
              };
      }
      var x_1 = Belt_List.reverse(acc);
      var x = {
        NAME: "arr",
        VAL: x_1
      };
      return {
              TAG: /* Ok */0,
              _0: [
                x,
                next
              ]
            };
    }
    var m = with_next(sloc, next, value);
    return bind$1(m, (function (param) {
                  var v = param[0];
                  return with_next(sloc, param[1], (function (_nloc) {
                                var partial_arg = {
                                  hd: v,
                                  tl: acc
                                };
                                return function (param, param$1) {
                                  return collect_array(partial_arg, sloc, param, param$1);
                                };
                              }));
                }));
  };
  var collect_object = function (acc, sloc, next, tok) {
    if (typeof tok === "object") {
      if (tok.NAME !== "Name") {
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "unexpected_token_at",
                  VAL: [
                    sloc,
                    tok
                  ]
                }
              };
      }
      var key = tok.VAL;
      var m = with_next(sloc, next, value);
      return bind$1(m, (function (param) {
                    var v = param[0];
                    return with_next(sloc, param[1], (function (_nloc) {
                                  var partial_arg_0 = [
                                    key,
                                    v
                                  ];
                                  var partial_arg = {
                                    hd: partial_arg_0,
                                    tl: acc
                                  };
                                  return function (param, param$1) {
                                    return collect_object(partial_arg, sloc, param, param$1);
                                  };
                                }));
                  }));
    }
    if (tok !== "Oe") {
      return {
              TAG: /* Error */1,
              _0: {
                NAME: "unexpected_token_at",
                VAL: [
                  sloc,
                  tok
                ]
              }
            };
    }
    var x_1 = Belt_List.reverse(acc);
    var x = {
      NAME: "obj",
      VAL: x_1
    };
    return {
            TAG: /* Ok */0,
            _0: [
              x,
              next
            ]
          };
  };
  var match = Curry._1(input, undefined);
  if (!match) {
    return {
            TAG: /* Error */1,
            _0: "empty_document"
          };
  }
  var match$1 = match._0;
  return value(match$1[0], match._1, match$1[1]);
}

function of_jsonm(jsonm) {
  return map$1((function (param) {
                var rest = param[1];
                return [
                        param[0],
                        (function (param) {
                            return map((function (prim) {
                                          return prim[1];
                                        }), rest, param);
                          })
                      ];
              }), to_option(of_jsonm$p(function (param) {
                      return map((function (tok) {
                                    return [
                                            undefined,
                                            tok
                                          ];
                                  }), jsonm, param);
                    })));
}

function to_jsonm(param) {
  if (typeof param !== "object") {
    return function (param) {
      return /* Cons */{
              _0: "Null",
              _1: empty
            };
    };
  }
  var variant = param.NAME;
  if (variant === "arr") {
    var partial_arg = fold_right$1((function (x, seq) {
            var partial_arg = to_jsonm(x);
            return function (param) {
              return append(partial_arg, seq, param);
            };
          }), param.VAL, (function (param) {
            return /* Cons */{
                    _0: "Ae",
                    _1: empty
                  };
          }));
    return function (param) {
      return /* Cons */{
              _0: "As",
              _1: partial_arg
            };
    };
  }
  if (variant === "num") {
    var partial_arg_1 = param.VAL;
    var partial_arg$1 = {
      NAME: "Float",
      VAL: partial_arg_1
    };
    return function (param) {
      return /* Cons */{
              _0: partial_arg$1,
              _1: empty
            };
    };
  }
  if (variant === "obj") {
    var partial_arg$2 = fold_right$1((function (param, seq) {
            var partial_arg = to_jsonm(param[1]);
            var partial_arg_1 = param[0];
            var partial_arg$1 = {
              NAME: "Name",
              VAL: partial_arg_1
            };
            var partial_arg$2 = function (param) {
              return /* Cons */{
                      _0: partial_arg$1,
                      _1: partial_arg
                    };
            };
            return function (param) {
              return append(partial_arg$2, seq, param);
            };
          }), param.VAL, (function (param) {
            return /* Cons */{
                    _0: "Oe",
                    _1: empty
                  };
          }));
    return function (param) {
      return /* Cons */{
              _0: "Os",
              _1: partial_arg$2
            };
    };
  }
  if (variant === "str") {
    var partial_arg_1$1 = param.VAL;
    var partial_arg$3 = {
      NAME: "String",
      VAL: partial_arg_1$1
    };
    return function (param) {
      return /* Cons */{
              _0: partial_arg$3,
              _1: empty
            };
    };
  }
  var partial_arg_1$2 = param.VAL;
  var partial_arg$4 = {
    NAME: "Bool",
    VAL: partial_arg_1$2
  };
  return function (param) {
    return /* Cons */{
            _0: partial_arg$4,
            _1: empty
          };
  };
}

var Json = {
  of_legacy: of_legacy,
  to_legacy: to_legacy,
  of_yojson: of_yojson,
  to_yojson: to_yojson,
  yojson_basic_of_safe: yojson_basic_of_safe,
  yojson_safe_of_basic: yojson_safe_of_basic,
  of_jsonm$p: of_jsonm$p,
  of_jsonm: of_jsonm,
  to_jsonm: to_jsonm
};

function pump_field(fname, jv) {
  if (typeof jv !== "object") {
    return jv;
  }
  if (jv.NAME !== "obj") {
    return jv;
  }
  var fs = jv.VAL;
  if (fs && !fs.tl) {
    return jv;
  }
  var match = deassoc_opt(fname, fs);
  var fval = match[0];
  if (fval !== undefined) {
    return {
            NAME: "obj",
            VAL: {
              hd: [
                fname,
                fval
              ],
              tl: match[1]
            }
          };
  } else {
    return jv;
  }
}

var Jv = {
  pump_field: pump_field
};

function Make(C) {
  var c62 = C.c62;
  var c63 = C.c63;
  var sixbit_to_char = function (b) {
    if (b < 26) {
      return b + /* 'A' */65 | 0;
    } else if (b < 52) {
      return (b - 26 | 0) + /* 'a' */97 | 0;
    } else if (b < 62) {
      return (b - 52 | 0) + /* '0' */48 | 0;
    } else if (b === 62) {
      return c62;
    } else {
      return c63;
    }
  };
  var char_to_sixbit = function (c) {
    if (/* 'A' */65 <= c && c <= /* 'Z' */90) {
      return c - /* 'A' */65 | 0;
    } else if (/* 'a' */97 <= c && c <= /* 'z' */122) {
      return (c - /* 'a' */97 | 0) + 26 | 0;
    } else if (/* '0' */48 <= c && c <= /* '9' */57) {
      return (c - /* '0' */48 | 0) + 52 | 0;
    } else if (c === c62) {
      return 62;
    } else if (c === c63) {
      return 63;
    } else {
      return ;
    }
  };
  var encode_buf = function (offsetOpt, len, output, input) {
    var offset = offsetOpt !== undefined ? offsetOpt : 0;
    var orig_len = input.length;
    var len$1 = v(orig_len - offset | 0, len);
    var end_index = offset + len$1 | 0;
    var match = len$1 < 0 || end_index > orig_len ? Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "Base64.encode: the input range (offset:",
                  _1: {
                    TAG: /* Int */4,
                    _0: /* Int_d */0,
                    _1: /* No_padding */0,
                    _2: /* No_precision */0,
                    _3: {
                      TAG: /* String_literal */11,
                      _0: ", len:",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is out of bounds",
                          _1: /* End_of_format */0
                        }
                      }
                    }
                  }
                },
                _1: "Base64.encode: the input range (offset:%d, len:%d) is out of bounds"
              }), offset, len$1) : [
        offset,
        end_index,
        len$1
      ];
    var input_end = match[1];
    var estimated_chars = ((match[2] / 3 | 0) << 2) + 4 | 0;
    var output_buf = create$1(estimated_chars);
    var write = function (i, o, len) {
      var set = function (value, o) {
        add_int8(output_buf, sixbit_to_char(value & 63));
        return o + 1 | 0;
      };
      var b1 = Caml_bytes.get(input, i);
      var o$1 = set((b1 >>> 2), o);
      if (typeof len !== "object") {
        return set((b1 << 4), o$1);
      }
      var b2 = Caml_bytes.get(input, i + 1 | 0);
      var o$2 = set((b1 << 4) | (b2 >>> 4), o$1);
      if (typeof len.VAL !== "object") {
        return set((b2 << 2), o$2);
      }
      var b3 = Caml_bytes.get(input, i + 2 | 0);
      return set(b3, set((b2 << 2) | (b3 >>> 6), o$2));
    };
    var go = function (_i, _o) {
      while(true) {
        var o = _o;
        var i = _i;
        var match = input_end - i | 0;
        switch (match) {
          case 0 :
              var pad = C.pad;
              if (pad === undefined) {
                return o;
              }
              var match$1 = o % 4;
              var pad_chars;
              switch (match$1) {
                case 0 :
                    pad_chars = 0;
                    break;
                case 1 :
                    pad_chars = Pervasives.failwith("impossible");
                    break;
                case 2 :
                    pad_chars = 2;
                    break;
                case 3 :
                    pad_chars = 1;
                    break;
                default:
                  pad_chars = Pervasives.failwith("impossible");
              }
              return Belt_List.reduce(range$1(undefined)(0, pad_chars), o, (function(pad){
                        return function (o, param) {
                          add_char(output_buf, pad);
                          return o + 1 | 0;
                        }
                        }(pad)));
          case 1 :
              _o = write(i, o, "I");
              _i = i + 1 | 0;
              continue ;
          case 2 :
              _o = write(i, o, {
                    NAME: "S",
                    VAL: "I"
                  });
              _i = i + 2 | 0;
              continue ;
          default:
            _o = write(i, o, {
                  NAME: "S",
                  VAL: {
                    NAME: "S",
                    VAL: "I"
                  }
                });
            _i = i + 3 | 0;
            continue ;
        }
      };
    };
    var total_bytes = go(match[0], 0);
    add_buffer(output, output_buf);
    return total_bytes;
  };
  var encode = function (offset, len, input) {
    var output = create$1(0);
    encode_buf(offset, len, output, input);
    return contents(output);
  };
  var decode_buf = function (offsetOpt, len, output, input) {
    var offset = offsetOpt !== undefined ? offsetOpt : 0;
    var input$1 = Bytes.of_string(input);
    var orig_len = input$1.length;
    var len$1 = v(orig_len - offset | 0, len);
    var end_index = offset + len$1 | 0;
    var match = len$1 < 0 || end_index > orig_len ? Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
                _0: {
                  TAG: /* String_literal */11,
                  _0: "Base64.encode: the input range (offset:",
                  _1: {
                    TAG: /* Int */4,
                    _0: /* Int_d */0,
                    _1: /* No_padding */0,
                    _2: /* No_precision */0,
                    _3: {
                      TAG: /* String_literal */11,
                      _0: ", len:",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: ") is out of bounds",
                          _1: /* End_of_format */0
                        }
                      }
                    }
                  }
                },
                _1: "Base64.encode: the input range (offset:%d, len:%d) is out of bounds"
              }), offset, len$1) : (
        C.pad !== undefined && len$1 % 4 !== 0 ? Pervasives.invalid_arg("Base64.decode: wrong padding") : [
            offset,
            end_index,
            len$1
          ]
      );
    var input_end = match[1];
    var estimated_bytes = Math.imul(match[2] / 4 | 0, 3) + 2 | 0;
    var output_buf = create$1(estimated_bytes);
    var read = function (stack, o) {
      var set = function (o, value) {
        add_int8(output_buf, value & 255);
        return o + 1 | 0;
      };
      var match = Belt_List.reverse(stack);
      if (!match) {
        return o;
      }
      var match$1 = match.tl;
      if (!match$1) {
        return Pervasives.invalid_arg("Base64.decode: unterminated input");
      }
      var ss = match$1.tl;
      var s2 = match$1.hd;
      var o$1 = set(o, (match.hd << 2) | (s2 >>> 4));
      if (!ss) {
        if ((s2 & 15) !== 0) {
          return Pervasives.invalid_arg("Base64.decode: unterminated input");
        } else {
          return o$1;
        }
      }
      var ss$1 = ss.tl;
      var s3 = ss.hd;
      var o$2 = set(o$1, (s2 << 4) | (s3 >>> 2));
      if (ss$1) {
        if (ss$1.tl) {
          return Pervasives.failwith("impossible");
        } else {
          return set(o$2, (s3 << 6) | ss$1.hd);
        }
      } else if ((s3 & 3) !== 0) {
        return Pervasives.invalid_arg("Base64.decode: unterminated input");
      } else {
        return o$2;
      }
    };
    var go = function (_stack, _i, _o) {
      while(true) {
        var o = _o;
        var i = _i;
        var stack = _stack;
        if (i === input_end) {
          return read(stack, o);
        }
        var c = Caml_bytes.get(input$1, i);
        var s = char_to_sixbit(c);
        if (s !== undefined) {
          var stack$1 = {
            hd: s,
            tl: stack
          };
          if (Belt_List.length(stack$1) === 4) {
            var o$1 = read(stack$1, o);
            _o = o$1;
            _i = i + 1 | 0;
            _stack = /* [] */0;
            continue ;
          }
          _i = i + 1 | 0;
          _stack = stack$1;
          continue ;
        }
        var c$1 = Pervasives.char_of_int(c);
        var exit = 0;
        var exit$1 = 0;
        if (C.ignore_unknown) {
          _i = i + 1 | 0;
          continue ;
        }
        exit = 1;
        if (exit$1 === 2) {
          if (C.ignore_newline) {
            _i = i + 1 | 0;
            continue ;
          }
          exit = 1;
        }
        if (exit === 1) {
          var pad = C.pad;
          var exit$2 = 0;
          if (pad !== undefined) {
            if (c$1 === pad) {
              var rest = Bytes.sub_string(input$1, i, input_end - i | 0);
              var rest_len = rest.length;
              var valid = rest_len > 0 && rest_len <= 2 ? iotafl(rest_len, (function(rest,pad){
                    return function (acc, i) {
                      if (acc) {
                        return Caml_string.get(rest, i) === pad;
                      } else {
                        return false;
                      }
                    }
                    }(rest,pad)), true) : false;
              if (valid) {
                return read(stack, o);
              } else {
                return Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "Base64.decode: invalid char '",
                                  _1: {
                                    TAG: /* Char */0,
                                    _0: {
                                      TAG: /* String_literal */11,
                                      _0: "' at index ",
                                      _1: {
                                        TAG: /* Int */4,
                                        _0: /* Int_d */0,
                                        _1: /* No_padding */0,
                                        _2: /* No_precision */0,
                                        _3: /* End_of_format */0
                                      }
                                    }
                                  }
                                },
                                _1: "Base64.decode: invalid char '%c' at index %d"
                              }), pad, i);
              }
            }
            exit$2 = 2;
          } else {
            exit$2 = 2;
          }
          if (exit$2 === 2) {
            return Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "Base64.decode: invalid char '",
                              _1: {
                                TAG: /* Char */0,
                                _0: {
                                  TAG: /* String_literal */11,
                                  _0: "' at index ",
                                  _1: {
                                    TAG: /* Int */4,
                                    _0: /* Int_d */0,
                                    _1: /* No_padding */0,
                                    _2: /* No_precision */0,
                                    _3: /* End_of_format */0
                                  }
                                }
                              }
                            },
                            _1: "Base64.decode: invalid char '%c' at index %d"
                          }), c$1, i);
          }
          
        }
        
      };
    };
    var total_bytes = go(/* [] */0, match[0], 0);
    add_buffer(output, output_buf);
    return total_bytes;
  };
  var decode = function (offset, len, input) {
    var output = create$1(0);
    decode_buf(offset, len, output, input);
    return to_bytes(output);
  };
  return {
          encode_buf: encode_buf,
          decode_buf: decode_buf,
          encode: encode,
          decode: decode
        };
}

var pad = /* '=' */61;

var Config_rfc4648 = {
  c62: /* '+' */43,
  c63: /* '/' */47,
  pad: pad,
  ignore_newline: false,
  ignore_unknown: false
};

function sixbit_to_char(b) {
  if (b < 26) {
    return b + /* 'A' */65 | 0;
  } else if (b < 52) {
    return (b - 26 | 0) + /* 'a' */97 | 0;
  } else if (b < 62) {
    return (b - 52 | 0) + /* '0' */48 | 0;
  } else if (b === 62) {
    return /* '+' */43;
  } else {
    return /* '/' */47;
  }
}

function char_to_sixbit(c) {
  if (/* 'A' */65 <= c && c <= /* 'Z' */90) {
    return c - /* 'A' */65 | 0;
  } else if (/* 'a' */97 <= c && c <= /* 'z' */122) {
    return (c - /* 'a' */97 | 0) + 26 | 0;
  } else if (/* '0' */48 <= c && c <= /* '9' */57) {
    return (c - /* '0' */48 | 0) + 52 | 0;
  } else if (c === /* '+' */43) {
    return 62;
  } else if (c === /* '/' */47) {
    return 63;
  } else {
    return ;
  }
}

function encode_buf(offsetOpt, len, output, input) {
  var offset = offsetOpt !== undefined ? offsetOpt : 0;
  var orig_len = input.length;
  var len$1 = v(orig_len - offset | 0, len);
  var end_index = offset + len$1 | 0;
  var match = len$1 < 0 || end_index > orig_len ? Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "Base64.encode: the input range (offset:",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: {
                    TAG: /* String_literal */11,
                    _0: ", len:",
                    _1: {
                      TAG: /* Int */4,
                      _0: /* Int_d */0,
                      _1: /* No_padding */0,
                      _2: /* No_precision */0,
                      _3: {
                        TAG: /* String_literal */11,
                        _0: ") is out of bounds",
                        _1: /* End_of_format */0
                      }
                    }
                  }
                }
              },
              _1: "Base64.encode: the input range (offset:%d, len:%d) is out of bounds"
            }), offset, len$1) : [
      offset,
      end_index,
      len$1
    ];
  var input_end = match[1];
  var estimated_chars = ((match[2] / 3 | 0) << 2) + 4 | 0;
  var output_buf = create$1(estimated_chars);
  var write = function (i, o, len) {
    var set = function (value, o) {
      add_int8(output_buf, sixbit_to_char(value & 63));
      return o + 1 | 0;
    };
    var b1 = Caml_bytes.get(input, i);
    var o$1 = set((b1 >>> 2), o);
    if (typeof len !== "object") {
      return set((b1 << 4), o$1);
    }
    var b2 = Caml_bytes.get(input, i + 1 | 0);
    var o$2 = set((b1 << 4) | (b2 >>> 4), o$1);
    if (typeof len.VAL !== "object") {
      return set((b2 << 2), o$2);
    }
    var b3 = Caml_bytes.get(input, i + 2 | 0);
    return set(b3, set((b2 << 2) | (b3 >>> 6), o$2));
  };
  var go = function (_i, _o) {
    while(true) {
      var o = _o;
      var i = _i;
      var match = input_end - i | 0;
      switch (match) {
        case 0 :
            if (pad === undefined) {
              return o;
            }
            var match$1 = o % 4;
            var pad_chars;
            switch (match$1) {
              case 0 :
                  pad_chars = 0;
                  break;
              case 1 :
                  pad_chars = Pervasives.failwith("impossible");
                  break;
              case 2 :
                  pad_chars = 2;
                  break;
              case 3 :
                  pad_chars = 1;
                  break;
              default:
                pad_chars = Pervasives.failwith("impossible");
            }
            return Belt_List.reduce(range$1(undefined)(0, pad_chars), o, (function (o, param) {
                          add_char(output_buf, pad);
                          return o + 1 | 0;
                        }));
        case 1 :
            _o = write(i, o, "I");
            _i = i + 1 | 0;
            continue ;
        case 2 :
            _o = write(i, o, {
                  NAME: "S",
                  VAL: "I"
                });
            _i = i + 2 | 0;
            continue ;
        default:
          _o = write(i, o, {
                NAME: "S",
                VAL: {
                  NAME: "S",
                  VAL: "I"
                }
              });
          _i = i + 3 | 0;
          continue ;
      }
    };
  };
  var total_bytes = go(match[0], 0);
  add_buffer(output, output_buf);
  return total_bytes;
}

function encode(offset, len, input) {
  var output = create$1(0);
  encode_buf(offset, len, output, input);
  return contents(output);
}

function decode_buf(offsetOpt, len, output, input) {
  var offset = offsetOpt !== undefined ? offsetOpt : 0;
  var input$1 = Bytes.of_string(input);
  var orig_len = input$1.length;
  var len$1 = v(orig_len - offset | 0, len);
  var end_index = offset + len$1 | 0;
  var match = len$1 < 0 || end_index > orig_len ? Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "Base64.encode: the input range (offset:",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: {
                    TAG: /* String_literal */11,
                    _0: ", len:",
                    _1: {
                      TAG: /* Int */4,
                      _0: /* Int_d */0,
                      _1: /* No_padding */0,
                      _2: /* No_precision */0,
                      _3: {
                        TAG: /* String_literal */11,
                        _0: ") is out of bounds",
                        _1: /* End_of_format */0
                      }
                    }
                  }
                }
              },
              _1: "Base64.encode: the input range (offset:%d, len:%d) is out of bounds"
            }), offset, len$1) : (
      pad !== undefined && len$1 % 4 !== 0 ? Pervasives.invalid_arg("Base64.decode: wrong padding") : [
          offset,
          end_index,
          len$1
        ]
    );
  var input_end = match[1];
  var estimated_bytes = Math.imul(match[2] / 4 | 0, 3) + 2 | 0;
  var output_buf = create$1(estimated_bytes);
  var read = function (stack, o) {
    var set = function (o, value) {
      add_int8(output_buf, value & 255);
      return o + 1 | 0;
    };
    var match = Belt_List.reverse(stack);
    if (!match) {
      return o;
    }
    var match$1 = match.tl;
    if (!match$1) {
      return Pervasives.invalid_arg("Base64.decode: unterminated input");
    }
    var ss = match$1.tl;
    var s2 = match$1.hd;
    var o$1 = set(o, (match.hd << 2) | (s2 >>> 4));
    if (!ss) {
      if ((s2 & 15) !== 0) {
        return Pervasives.invalid_arg("Base64.decode: unterminated input");
      } else {
        return o$1;
      }
    }
    var ss$1 = ss.tl;
    var s3 = ss.hd;
    var o$2 = set(o$1, (s2 << 4) | (s3 >>> 2));
    if (ss$1) {
      if (ss$1.tl) {
        return Pervasives.failwith("impossible");
      } else {
        return set(o$2, (s3 << 6) | ss$1.hd);
      }
    } else if ((s3 & 3) !== 0) {
      return Pervasives.invalid_arg("Base64.decode: unterminated input");
    } else {
      return o$2;
    }
  };
  var go = function (_stack, _i, _o) {
    while(true) {
      var o = _o;
      var i = _i;
      var stack = _stack;
      if (i === input_end) {
        return read(stack, o);
      }
      var c = Caml_bytes.get(input$1, i);
      var s = char_to_sixbit(c);
      if (s !== undefined) {
        var stack$1 = {
          hd: s,
          tl: stack
        };
        if (Belt_List.length(stack$1) === 4) {
          var o$1 = read(stack$1, o);
          _o = o$1;
          _i = i + 1 | 0;
          _stack = /* [] */0;
          continue ;
        }
        _i = i + 1 | 0;
        _stack = stack$1;
        continue ;
      }
      var c$1 = Pervasives.char_of_int(c);
      var exit = 0;
      exit = 1;
      if (exit === 1) {
        var exit$1 = 0;
        if (pad !== undefined) {
          if (c$1 === pad) {
            var rest = Bytes.sub_string(input$1, i, input_end - i | 0);
            var rest_len = rest.length;
            var valid = rest_len > 0 && rest_len <= 2 ? iotafl(rest_len, (function(rest){
                  return function (acc, i) {
                    if (acc) {
                      return Caml_string.get(rest, i) === pad;
                    } else {
                      return false;
                    }
                  }
                  }(rest)), true) : false;
            if (valid) {
              return read(stack, o);
            } else {
              return Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "Base64.decode: invalid char '",
                                _1: {
                                  TAG: /* Char */0,
                                  _0: {
                                    TAG: /* String_literal */11,
                                    _0: "' at index ",
                                    _1: {
                                      TAG: /* Int */4,
                                      _0: /* Int_d */0,
                                      _1: /* No_padding */0,
                                      _2: /* No_precision */0,
                                      _3: /* End_of_format */0
                                    }
                                  }
                                }
                              },
                              _1: "Base64.decode: invalid char '%c' at index %d"
                            }), pad, i);
            }
          }
          exit$1 = 2;
        } else {
          exit$1 = 2;
        }
        if (exit$1 === 2) {
          return Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Base64.decode: invalid char '",
                            _1: {
                              TAG: /* Char */0,
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "' at index ",
                                _1: {
                                  TAG: /* Int */4,
                                  _0: /* Int_d */0,
                                  _1: /* No_padding */0,
                                  _2: /* No_precision */0,
                                  _3: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "Base64.decode: invalid char '%c' at index %d"
                        }), c$1, i);
        }
        
      }
      
    };
  };
  var total_bytes = go(/* [] */0, match[0], 0);
  add_buffer(output, output_buf);
  return total_bytes;
}

function decode(offset, len, input) {
  var output = create$1(0);
  decode_buf(offset, len, output, input);
  return to_bytes(output);
}

var Config_rfc4648_url = {
  c62: /* '-' */45,
  c63: /* '_' */95,
  pad: undefined,
  ignore_newline: false,
  ignore_unknown: false
};

function sixbit_to_char$1(b) {
  if (b < 26) {
    return b + /* 'A' */65 | 0;
  } else if (b < 52) {
    return (b - 26 | 0) + /* 'a' */97 | 0;
  } else if (b < 62) {
    return (b - 52 | 0) + /* '0' */48 | 0;
  } else if (b === 62) {
    return /* '-' */45;
  } else {
    return /* '_' */95;
  }
}

function char_to_sixbit$1(c) {
  if (/* 'A' */65 <= c && c <= /* 'Z' */90) {
    return c - /* 'A' */65 | 0;
  } else if (/* 'a' */97 <= c && c <= /* 'z' */122) {
    return (c - /* 'a' */97 | 0) + 26 | 0;
  } else if (/* '0' */48 <= c && c <= /* '9' */57) {
    return (c - /* '0' */48 | 0) + 52 | 0;
  } else if (c === /* '-' */45) {
    return 62;
  } else if (c === /* '_' */95) {
    return 63;
  } else {
    return ;
  }
}

function encode_buf$1(offsetOpt, len, output, input) {
  var offset = offsetOpt !== undefined ? offsetOpt : 0;
  var orig_len = input.length;
  var len$1 = v(orig_len - offset | 0, len);
  var end_index = offset + len$1 | 0;
  var match = len$1 < 0 || end_index > orig_len ? Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "Base64.encode: the input range (offset:",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: {
                    TAG: /* String_literal */11,
                    _0: ", len:",
                    _1: {
                      TAG: /* Int */4,
                      _0: /* Int_d */0,
                      _1: /* No_padding */0,
                      _2: /* No_precision */0,
                      _3: {
                        TAG: /* String_literal */11,
                        _0: ") is out of bounds",
                        _1: /* End_of_format */0
                      }
                    }
                  }
                }
              },
              _1: "Base64.encode: the input range (offset:%d, len:%d) is out of bounds"
            }), offset, len$1) : [
      offset,
      end_index,
      len$1
    ];
  var input_end = match[1];
  var estimated_chars = ((match[2] / 3 | 0) << 2) + 4 | 0;
  var output_buf = create$1(estimated_chars);
  var write = function (i, o, len) {
    var set = function (value, o) {
      add_int8(output_buf, sixbit_to_char$1(value & 63));
      return o + 1 | 0;
    };
    var b1 = Caml_bytes.get(input, i);
    var o$1 = set((b1 >>> 2), o);
    if (typeof len !== "object") {
      return set((b1 << 4), o$1);
    }
    var b2 = Caml_bytes.get(input, i + 1 | 0);
    var o$2 = set((b1 << 4) | (b2 >>> 4), o$1);
    if (typeof len.VAL !== "object") {
      return set((b2 << 2), o$2);
    }
    var b3 = Caml_bytes.get(input, i + 2 | 0);
    return set(b3, set((b2 << 2) | (b3 >>> 6), o$2));
  };
  var go = function (_i, _o) {
    while(true) {
      var o = _o;
      var i = _i;
      var match = input_end - i | 0;
      switch (match) {
        case 0 :
            return o;
        case 1 :
            _o = write(i, o, "I");
            _i = i + 1 | 0;
            continue ;
        case 2 :
            _o = write(i, o, {
                  NAME: "S",
                  VAL: "I"
                });
            _i = i + 2 | 0;
            continue ;
        default:
          _o = write(i, o, {
                NAME: "S",
                VAL: {
                  NAME: "S",
                  VAL: "I"
                }
              });
          _i = i + 3 | 0;
          continue ;
      }
    };
  };
  var total_bytes = go(match[0], 0);
  add_buffer(output, output_buf);
  return total_bytes;
}

function encode$1(offset, len, input) {
  var output = create$1(0);
  encode_buf$1(offset, len, output, input);
  return contents(output);
}

function decode_buf$1(offsetOpt, len, output, input) {
  var offset = offsetOpt !== undefined ? offsetOpt : 0;
  var input$1 = Bytes.of_string(input);
  var orig_len = input$1.length;
  var len$1 = v(orig_len - offset | 0, len);
  var end_index = offset + len$1 | 0;
  var match = len$1 < 0 || end_index > orig_len ? Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
              _0: {
                TAG: /* String_literal */11,
                _0: "Base64.encode: the input range (offset:",
                _1: {
                  TAG: /* Int */4,
                  _0: /* Int_d */0,
                  _1: /* No_padding */0,
                  _2: /* No_precision */0,
                  _3: {
                    TAG: /* String_literal */11,
                    _0: ", len:",
                    _1: {
                      TAG: /* Int */4,
                      _0: /* Int_d */0,
                      _1: /* No_padding */0,
                      _2: /* No_precision */0,
                      _3: {
                        TAG: /* String_literal */11,
                        _0: ") is out of bounds",
                        _1: /* End_of_format */0
                      }
                    }
                  }
                }
              },
              _1: "Base64.encode: the input range (offset:%d, len:%d) is out of bounds"
            }), offset, len$1) : (
      undefined !== undefined && len$1 % 4 !== 0 ? Pervasives.invalid_arg("Base64.decode: wrong padding") : [
          offset,
          end_index,
          len$1
        ]
    );
  var input_end = match[1];
  var estimated_bytes = Math.imul(match[2] / 4 | 0, 3) + 2 | 0;
  var output_buf = create$1(estimated_bytes);
  var read = function (stack, o) {
    var set = function (o, value) {
      add_int8(output_buf, value & 255);
      return o + 1 | 0;
    };
    var match = Belt_List.reverse(stack);
    if (!match) {
      return o;
    }
    var match$1 = match.tl;
    if (!match$1) {
      return Pervasives.invalid_arg("Base64.decode: unterminated input");
    }
    var ss = match$1.tl;
    var s2 = match$1.hd;
    var o$1 = set(o, (match.hd << 2) | (s2 >>> 4));
    if (!ss) {
      if ((s2 & 15) !== 0) {
        return Pervasives.invalid_arg("Base64.decode: unterminated input");
      } else {
        return o$1;
      }
    }
    var ss$1 = ss.tl;
    var s3 = ss.hd;
    var o$2 = set(o$1, (s2 << 4) | (s3 >>> 2));
    if (ss$1) {
      if (ss$1.tl) {
        return Pervasives.failwith("impossible");
      } else {
        return set(o$2, (s3 << 6) | ss$1.hd);
      }
    } else if ((s3 & 3) !== 0) {
      return Pervasives.invalid_arg("Base64.decode: unterminated input");
    } else {
      return o$2;
    }
  };
  var go = function (_stack, _i, _o) {
    while(true) {
      var o = _o;
      var i = _i;
      var stack = _stack;
      if (i === input_end) {
        return read(stack, o);
      }
      var c = Caml_bytes.get(input$1, i);
      var s = char_to_sixbit$1(c);
      if (s !== undefined) {
        var stack$1 = {
          hd: s,
          tl: stack
        };
        if (Belt_List.length(stack$1) === 4) {
          var o$1 = read(stack$1, o);
          _o = o$1;
          _i = i + 1 | 0;
          _stack = /* [] */0;
          continue ;
        }
        _i = i + 1 | 0;
        _stack = stack$1;
        continue ;
      }
      var c$1 = Pervasives.char_of_int(c);
      var exit = 0;
      exit = 1;
      if (exit === 1) {
        var exit$1 = 0;
        exit$1 = 2;
        if (exit$1 === 2) {
          return Curry._2(Format.kasprintf(Pervasives.invalid_arg, /* Format */{
                          _0: {
                            TAG: /* String_literal */11,
                            _0: "Base64.decode: invalid char '",
                            _1: {
                              TAG: /* Char */0,
                              _0: {
                                TAG: /* String_literal */11,
                                _0: "' at index ",
                                _1: {
                                  TAG: /* Int */4,
                                  _0: /* Int_d */0,
                                  _1: /* No_padding */0,
                                  _2: /* No_precision */0,
                                  _3: /* End_of_format */0
                                }
                              }
                            }
                          },
                          _1: "Base64.decode: invalid char '%c' at index %d"
                        }), c$1, i);
        }
        
      }
      
    };
  };
  var total_bytes = go(/* [] */0, match[0], 0);
  add_buffer(output, output_buf);
  return total_bytes;
}

function decode$1(offset, len, input) {
  var output = create$1(0);
  decode_buf$1(offset, len, output, input);
  return to_bytes(output);
}

var Url = {
  encode_buf: encode_buf$1,
  decode_buf: decode_buf$1,
  encode: encode$1,
  decode: decode$1
};

var Base64 = {
  Make: Make,
  Config_rfc4648: Config_rfc4648,
  encode_buf: encode_buf,
  decode_buf: decode_buf,
  encode: encode,
  decode: decode,
  Config_rfc4648_url: Config_rfc4648_url,
  Url: Url
};

var Fn;

var foldl = fold_left$2;

var none;

var pp_int = Format.pp_print_int;

var pp_float = Format.pp_print_float;

var pp_string = Format.pp_print_string;

var pp_char = Format.pp_print_char;

var pp_bool = Format.pp_print_bool;

exports.Kxclib_comp_re = Kxclib_comp_re;
exports.Kxclib_comp = Kxclib_comp;
exports.refset = refset;
exports.refupdate = refupdate;
exports.refappend = refappend;
exports.refupdate$p = refupdate$p;
exports.refappend$p = refappend$p;
exports.refpop = refpop;
exports.incr = incr;
exports.decr = decr;
exports.refupdate$p_and_get = refupdate$p_and_get;
exports.get_and_refupdate$p = get_and_refupdate$p;
exports.incr_and_get = incr_and_get;
exports.decr_and_get = decr_and_get;
exports.get_and_incr = get_and_incr;
exports.get_and_decr = get_and_decr;
exports.constant = constant;
exports.identity = identity;
exports.failwith$p = failwith$p;
exports.invalid_arg$p = invalid_arg$p;
exports.iotaf = iotaf;
exports.iotaf$p = iotaf$p;
exports.iotafl = iotafl;
exports.min_by = min_by;
exports.max_by = max_by;
exports.Functionals = Functionals;
exports.Fn = Fn;
exports.$percent = $percent;
exports.$percent$percent = $percent$percent;
exports.$amp$great = $amp$great;
exports.$amp$amp$great = $amp$amp$great;
exports.$pipe$neg$great = $pipe$neg$great;
exports.$slash$slash = $slash$slash;
exports.$slash$great = $slash$great;
exports.$slash$less = $slash$less;
exports.$question$great = $question$great;
exports.$question$less = $question$less;
exports.$bang$bang = $bang$bang;
exports.$bang$question = $bang$question;
exports.PipeOps = PipeOps;
exports.MonadOps = MonadOps;
exports.foldl = foldl;
exports.foldr = foldr;
exports.projected_compare = projected_compare;
exports.Either = Either;
exports.Result = Result$1;
exports.ResultOf = ResultOf;
exports.ResultWithErrmsg = ResultWithErrmsg;
exports.Queue = Queue;
exports.$$Option = $$Option$1;
exports.some = some;
exports.none = none;
exports.$great$question = $great$question;
exports.$great$great$question = $great$great$question;
exports.$pipe$question = $pipe$question;
exports.$pipe$pipe$question = $pipe$pipe$question;
exports.$amp$great$question = $amp$great$question;
exports.Seq = Seq$1;
exports.$$Array = $$Array$2;
exports.Stream = Stream$1;
exports.List = List$1;
exports.$pipe$amp$great = $pipe$amp$great$3;
exports.$pipe$plus$amp$great = $pipe$plus$amp$great$3;
exports.$pipe$bang$great = $pipe$bang$great$3;
exports.$pipe$neg$bang$great = $pipe$neg$bang$great$3;
exports.$pipe$at$great = $pipe$at$great$3;
exports.$pipe$question$great = $pipe$question$great$3;
exports.$pipe$amp$question$great = $pipe$amp$question$great$3;
exports.$pipe$plus$amp$question$great = $pipe$plus$amp$question$great$3;
exports.iota = iota$1;
exports.Hashtbl = Hashtbl$2;
exports.$$String = $$String$2;
exports.IoPervasives = IoPervasives;
exports.with_input_file = with_input_file;
exports.with_output_file = with_output_file;
exports.slurp_input = slurp_input;
exports.slurp_stdin = slurp_stdin;
exports.slurp_file = slurp_file;
exports.spit_file = spit_file;
exports.Timing = Timing;
exports.Datetime0 = Datetime0;
exports.ParseArgs = ParseArgs;
exports.ArgOptions = ArgOptions;
exports.FmtPervasives = FmtPervasives;
exports.color_enabled = color_enabled;
exports.fprintf = fprintf;
exports.printf = printf;
exports.sprintf = sprintf;
exports.eprintf = eprintf;
exports.Fmt = Fmt;
exports.condformat = condformat;
exports.pp_of_to_string = pp_of_to_string;
exports.to_string_of_pp = to_string_of_pp;
exports.pps = pps;
exports.spp = spp;
exports.pp_int = pp_int;
exports.pp_float = pp_float;
exports.pp_string = pp_string;
exports.pp_char = pp_char;
exports.pp_bool = pp_bool;
exports.pp_unit = pp_unit;
exports.pp_ref_address = pp_ref_address;
exports.pp_int32 = pp_int32;
exports.pp_int64 = pp_int64;
exports.pp_integer_sep$p = pp_integer_sep$p;
exports.pp_integer_sep = pp_integer_sep;
exports.pp_multiline = pp_multiline;
exports.pp_exn = pp_exn;
exports.pp_full_exn$p = pp_full_exn$p;
exports.pp_full_exn = pp_full_exn;
exports.string_of_symbolic_output_items = string_of_symbolic_output_items;
exports.Log0 = Log0;
exports.debug = debug$1;
exports.info = info$1;
exports.Json = Json;
exports.Jv = Jv;
exports.Base64 = Base64;
/* max_int Not a pure module */
