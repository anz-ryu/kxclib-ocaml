// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("rescript/lib/js/sys.js");
var Caml = require("rescript/lib/js/caml.js");
var Bytes = require("rescript/lib/js/bytes.js");
var Curry = require("rescript/lib/js/curry.js");
var Uchar = require("rescript/lib/js/uchar.js");
var $$String = require("rescript/lib/js/string.js");
var Hashtbl = require("rescript/lib/js/hashtbl.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Js_types = require("rescript/lib/js/js_types.js");
var Printexc = require("rescript/lib/js/printexc.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var Caml_bytes = require("rescript/lib/js/caml_bytes.js");
var Caml_int32 = require("rescript/lib/js/caml_int32.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_string = require("rescript/lib/js/caml_string.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function _flip(f, a, b) {
  return Curry._2(f, b, a);
}

function _obj_make(param) {
  return {};
}

function _obj_set(o, k, v) {
  return (function(o, k, v){o[k] = v})(o, k, v);
}

function _obj_get(o, k) {
  return (function(o, k){return o[k]})(o, k);
}

function _stringify(x) {
  return (function(x){return ''+x;})(x);
}

var BaseCompInternals = {
  _flip: _flip,
  _obj_make: _obj_make,
  _obj_set: _obj_set,
  _obj_get: _obj_get,
  _stringify: _stringify
};

function empty(param) {
  return /* Nil */0;
}

function $$return(x, param) {
  return /* Cons */{
          _0: x,
          _1: empty
        };
}

function cons(x, next, param) {
  return /* Cons */{
          _0: x,
          _1: next
        };
}

function append(seq1, seq2, param) {
  var match = Curry._1(seq1, undefined);
  if (!match) {
    return Curry._1(seq2, undefined);
  }
  var next = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return append(next, seq2, param);
            })
        };
}

function map(f, seq, param) {
  var match = Curry._1(seq, undefined);
  if (!match) {
    return /* Nil */0;
  }
  var next = match._1;
  return /* Cons */{
          _0: Curry._1(f, match._0),
          _1: (function (param) {
              return map(f, next, param);
            })
        };
}

function filter_map(f, _seq, _param) {
  while(true) {
    var seq = _seq;
    var match = Curry._1(seq, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var next = match._1;
    var y = Curry._1(f, match._0);
    if (y !== undefined) {
      return /* Cons */{
              _0: Caml_option.valFromOption(y),
              _1: (function(next){
              return function (param) {
                return filter_map(f, next, param);
              }
              }(next))
            };
    }
    _param = undefined;
    _seq = next;
    continue ;
  };
}

function filter(f, _seq, _param) {
  while(true) {
    var seq = _seq;
    var match = Curry._1(seq, undefined);
    if (!match) {
      return /* Nil */0;
    }
    var next = match._1;
    var x = match._0;
    if (Curry._1(f, x)) {
      return /* Cons */{
              _0: x,
              _1: (function(next){
              return function (param) {
                return filter(f, next, param);
              }
              }(next))
            };
    }
    _param = undefined;
    _seq = next;
    continue ;
  };
}

function flat_map(f, seq, param) {
  var match = Curry._1(seq, undefined);
  if (match) {
    return flat_map_app(f, Curry._1(f, match._0), match._1, undefined);
  } else {
    return /* Nil */0;
  }
}

function flat_map_app(f, seq, tail, param) {
  var match = Curry._1(seq, undefined);
  if (!match) {
    return flat_map(f, tail, undefined);
  }
  var next = match._1;
  return /* Cons */{
          _0: match._0,
          _1: (function (param) {
              return flat_map_app(f, next, tail, param);
            })
        };
}

function fold_left(f, acc, seq) {
  var _acc = acc;
  var _seq = seq;
  while(true) {
    var seq$1 = _seq;
    var acc$1 = _acc;
    var match = Curry._1(seq$1, undefined);
    if (!match) {
      return acc$1;
    }
    var acc$2 = Curry._2(f, acc$1, match._0);
    _seq = match._1;
    _acc = acc$2;
    continue ;
  };
}

function iter(f, seq) {
  var _seq = seq;
  while(true) {
    var seq$1 = _seq;
    var match = Curry._1(seq$1, undefined);
    if (!match) {
      return ;
    }
    Curry._1(f, match._0);
    _seq = match._1;
    continue ;
  };
}

function unfold(f, u, param) {
  var match = Curry._1(f, u);
  if (match === undefined) {
    return /* Nil */0;
  }
  var u$p = match[1];
  return /* Cons */{
          _0: match[0],
          _1: (function (param) {
              return unfold(f, u$p, param);
            })
        };
}

var Seq = {
  empty: empty,
  $$return: $$return,
  cons: cons,
  append: append,
  map: map,
  filter_map: filter_map,
  filter: filter,
  flat_map: flat_map,
  flat_map_app: flat_map_app,
  fold_left: fold_left,
  iter: iter,
  unfold: unfold
};

function or_exn(e, x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  throw e;
}

function or_not_found(o) {
  return or_exn({
              RE_EXN_ID: "Not_found"
            }, o);
}

function some(v) {
  return Caml_option.some(v);
}

function value(o, $$default) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  } else {
    return $$default;
  }
}

function get(v) {
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  } else {
    return Pervasives.invalid_arg("option is None");
  }
}

function bind(o, f) {
  if (o !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(o));
  }
  
}

function join(o) {
  if (o !== undefined) {
    return Caml_option.valFromOption(o);
  }
  
}

function map$1(f, o) {
  if (o !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(o)));
  }
  
}

function fold(none, some, v) {
  if (v !== undefined) {
    return Curry._1(some, Caml_option.valFromOption(v));
  } else {
    return none;
  }
}

function iter$1(f, v) {
  if (v !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(v));
  }
  
}

function is_none(param) {
  return param === undefined;
}

function is_some(param) {
  return param !== undefined;
}

function equal(eq, o0, o1) {
  if (o0 !== undefined) {
    if (o1 !== undefined) {
      return Curry._2(eq, Caml_option.valFromOption(o0), Caml_option.valFromOption(o1));
    } else {
      return false;
    }
  } else {
    return o1 === undefined;
  }
}

function compare(cmp, o0, o1) {
  if (o0 !== undefined) {
    if (o1 !== undefined) {
      return Curry._2(cmp, Caml_option.valFromOption(o0), Caml_option.valFromOption(o1));
    } else {
      return 1;
    }
  } else if (o1 !== undefined) {
    return -1;
  } else {
    return 0;
  }
}

function to_result(none, v) {
  if (v !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(v)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: none
          };
  }
}

function to_list(v) {
  if (v !== undefined) {
    return {
            hd: Caml_option.valFromOption(v),
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

function to_seq(v) {
  if (v === undefined) {
    return empty;
  }
  var partial_arg = Caml_option.valFromOption(v);
  return function (param) {
    return /* Cons */{
            _0: partial_arg,
            _1: empty
          };
  };
}

var $$Option = {
  or_exn: or_exn,
  or_not_found: or_not_found,
  none: undefined,
  some: some,
  value: value,
  get: get,
  bind: bind,
  join: join,
  map: map$1,
  fold: fold,
  iter: iter$1,
  is_none: is_none,
  is_some: is_some,
  equal: equal,
  compare: compare,
  to_result: to_result,
  to_list: to_list,
  to_seq: to_seq
};

var Imported = {};

function length(arr) {
  return arr.length;
}

function get$1(arr) {
  return function (param) {
    return Belt_Array.getExn(arr, param);
  };
}

function set(arr) {
  return function (param, param$1) {
    return Belt_Array.setExn(arr, param, param$1);
  };
}

function make(n, x) {
  var arr = new Array(n);
  arr.fill(x);
  return arr;
}

var create = make;

function unsafe_get(arr) {
  return function (param) {
    return Belt_Array.getExn(arr, param);
  };
}

function unsafe_set(arr) {
  return function (param, param$1) {
    return Belt_Array.setExn(arr, param, param$1);
  };
}

function unsafe_fill(arr, ofs, len, v) {
  arr.fill(v, ofs, ofs + len | 0);
  
}

function append_prim(a1, a2) {
  return a1.concat(a2);
}

function unsafe_sub(arr, ofs, len) {
  var arr$p = new Array(len);
  for(var i = ofs; i < len; ++i){
    Caml_array.set(arr$p, i, Caml_array.get(arr, i));
  }
  return arr$p;
}

function unsafe_blit(src, src_ofs, dst, dst_ofs, len) {
  for(var i = 0; i < len; ++i){
    Caml_array.set(dst, dst_ofs + i | 0, Caml_array.get(src, src_ofs + i | 0));
  }
  
}

var Internals = {
  unsafe_get: unsafe_get,
  unsafe_set: unsafe_set,
  unsafe_fill: unsafe_fill,
  append_prim: append_prim,
  unsafe_sub: unsafe_sub,
  unsafe_blit: unsafe_blit
};

function init(l, f) {
  if (l === 0) {
    return [];
  }
  if (l < 0) {
    return Pervasives.invalid_arg("Array.init");
  }
  var res = make(l, Curry._1(f, 0));
  for(var i = 1; i < l; ++i){
    Belt_Array.setExn(res, i, Curry._1(f, i));
  }
  return res;
}

function copy(a) {
  var l = a.length;
  if (l === 0) {
    return [];
  } else {
    return unsafe_sub(a, 0, l);
  }
}

function append$1(a1, a2) {
  var l1 = a1.length;
  if (l1 === 0) {
    return copy(a2);
  } else if (a2.length === 0) {
    return unsafe_sub(a1, 0, l1);
  } else {
    return a1.concat(a2);
  }
}

function sub(a, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    return Pervasives.invalid_arg("Array.sub");
  } else {
    return unsafe_sub(a, ofs, len);
  }
}

function fill(a, ofs, len, v) {
  if (ofs < 0 || len < 0 || ofs > (a.length - len | 0)) {
    return Pervasives.invalid_arg("Array.fill");
  } else {
    return unsafe_fill(a, ofs, len, v);
  }
}

function blit(a1, ofs1, a2, ofs2, len) {
  if (len < 0 || ofs1 < 0 || ofs1 > (a1.length - len | 0) || ofs2 < 0 || ofs2 > (a2.length - len | 0)) {
    return Pervasives.invalid_arg("Array.blit");
  } else {
    return unsafe_blit(a1, ofs1, a2, ofs2, len);
  }
}

function iter$2(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._1(f, Belt_Array.getExn(a, i));
  }
  
}

function iter2(f, a, b) {
  if (a.length !== b.length) {
    return Pervasives.invalid_arg("Array.iter2: arrays must have the same length");
  }
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, Belt_Array.getExn(a, i), Belt_Array.getExn(b, i));
  }
  
}

function map$2(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = make(l, Curry._1(f, Belt_Array.getExn(a, 0)));
  for(var i = 1; i < l; ++i){
    Belt_Array.setExn(r, i, Curry._1(f, Belt_Array.getExn(a, i)));
  }
  return r;
}

function map2(f, a, b) {
  var la = a.length;
  var lb = b.length;
  if (la !== lb) {
    return Pervasives.invalid_arg("Array.map2: arrays must have the same length");
  }
  if (la === 0) {
    return [];
  }
  var r = make(la, Curry._2(f, Belt_Array.getExn(a, 0), Belt_Array.getExn(b, 0)));
  for(var i = 1; i < la; ++i){
    Belt_Array.setExn(r, i, Curry._2(f, Belt_Array.getExn(a, i), Belt_Array.getExn(b, i)));
  }
  return r;
}

function iteri(f, a) {
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, i, Belt_Array.getExn(a, i));
  }
  
}

function mapi(f, a) {
  var l = a.length;
  if (l === 0) {
    return [];
  }
  var r = make(l, Curry._2(f, 0, Belt_Array.getExn(a, 0)));
  for(var i = 1; i < l; ++i){
    Belt_Array.setExn(r, i, Curry._2(f, i, Belt_Array.getExn(a, i)));
  }
  return r;
}

function to_list$1(a) {
  var _i = a.length - 1 | 0;
  var _res = /* [] */0;
  while(true) {
    var res = _res;
    var i = _i;
    if (i < 0) {
      return res;
    }
    _res = {
      hd: Belt_Array.getExn(a, i),
      tl: res
    };
    _i = i - 1 | 0;
    continue ;
  };
}

function list_length(_accu, _param) {
  while(true) {
    var param = _param;
    var accu = _accu;
    if (!param) {
      return accu;
    }
    _param = param.tl;
    _accu = accu + 1 | 0;
    continue ;
  };
}

function of_list(l) {
  if (!l) {
    return [];
  }
  var a = make(list_length(0, l), l.hd);
  var _i = 1;
  var _param = l.tl;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return a;
    }
    Belt_Array.setExn(a, i, param.hd);
    _param = param.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function fold_left$1(f, x, a) {
  var r = x;
  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = Curry._2(f, r, Belt_Array.getExn(a, i));
  }
  return r;
}

function fold_right(f, a, x) {
  var r = x;
  for(var i = a.length - 1 | 0; i >= 0; --i){
    r = Curry._2(f, Belt_Array.getExn(a, i), r);
  }
  return r;
}

function exists(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, Belt_Array.getExn(a, i))) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all(p, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, Belt_Array.getExn(a, i))) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all2(p, l1, l2) {
  var n1 = l1.length;
  var n2 = l2.length;
  if (n1 !== n2) {
    return Pervasives.invalid_arg("Array.for_all2");
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n1) {
      return true;
    }
    if (!Curry._2(p, Belt_Array.getExn(l1, i), Belt_Array.getExn(l2, i))) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function exists2(p, l1, l2) {
  var n1 = l1.length;
  var n2 = l2.length;
  if (n1 !== n2) {
    return Pervasives.invalid_arg("Array.exists2");
  }
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n1) {
      return false;
    }
    if (Curry._2(p, Belt_Array.getExn(l1, i), Belt_Array.getExn(l2, i))) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function mem(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (Caml_obj.caml_equal(Belt_Array.getExn(a, i), x)) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function memq(x, a) {
  var n = a.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === n) {
      return false;
    }
    if (x === Belt_Array.getExn(a, i)) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

var Bottom = /* @__PURE__ */Caml_exceptions.create("Kxclib_comp_re.Kxclib_comp_re.Array.Bottom");

function sort(cmp, a) {
  var maxson = function (l, i) {
    var i31 = ((i + i | 0) + i | 0) + 1 | 0;
    var x = i31;
    if ((i31 + 2 | 0) < l) {
      if (Curry._2(cmp, Belt_Array.getExn(a, i31), Belt_Array.getExn(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (Curry._2(cmp, Belt_Array.getExn(a, x), Belt_Array.getExn(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    }
    if ((i31 + 1 | 0) < l && Curry._2(cmp, Belt_Array.getExn(a, i31), Belt_Array.getExn(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    }
    if (i31 < l) {
      return i31;
    }
    throw {
          RE_EXN_ID: Bottom,
          _1: i,
          Error: new Error()
        };
  };
  var trickle = function (l, i, e) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        if (Curry._2(cmp, Belt_Array.getExn(a, j), e) <= 0) {
          return Belt_Array.setExn(a, i$1, e);
        }
        Belt_Array.setExn(a, i$1, Belt_Array.getExn(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_i){
      var i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.RE_EXN_ID === Bottom) {
        return Belt_Array.setExn(a, i$2._1, e);
      }
      throw i$2;
    }
  };
  var bubble = function (l, i) {
    try {
      var _i = i;
      while(true) {
        var i$1 = _i;
        var j = maxson(l, i$1);
        Belt_Array.setExn(a, i$1, Belt_Array.getExn(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_i){
      var i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.RE_EXN_ID === Bottom) {
        return i$2._1;
      }
      throw i$2;
    }
  };
  var trickleup = function (_i, e) {
    while(true) {
      var i = _i;
      var father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "kxclib_comp_re.ml",
                366,
                4
              ],
              Error: new Error()
            };
      }
      if (Curry._2(cmp, Belt_Array.getExn(a, father), e) >= 0) {
        return Belt_Array.setExn(a, i, e);
      }
      Belt_Array.setExn(a, i, Belt_Array.getExn(a, father));
      if (father <= 0) {
        return Belt_Array.setExn(a, 0, e);
      }
      _i = father;
      continue ;
    };
  };
  var l = a.length;
  for(var i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i){
    trickle(l, i, Belt_Array.getExn(a, i));
  }
  for(var i$1 = l - 1 | 0; i$1 >= 2; --i$1){
    var e = Belt_Array.getExn(a, i$1);
    Belt_Array.setExn(a, i$1, Belt_Array.getExn(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l <= 1) {
    return ;
  }
  var e$1 = Belt_Array.getExn(a, 1);
  Belt_Array.setExn(a, 1, Belt_Array.getExn(a, 0));
  return Belt_Array.setExn(a, 0, e$1);
}

function stable_sort(cmp, a) {
  var merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    var src1r = src1ofs + src1len | 0;
    var src2r = src2ofs + src2len | 0;
    var _i1 = src1ofs;
    var _s1 = Belt_Array.getExn(a, src1ofs);
    var _i2 = src2ofs;
    var _s2 = Belt_Array.getExn(src2, src2ofs);
    var _d = dstofs;
    while(true) {
      var d = _d;
      var s2 = _s2;
      var i2 = _i2;
      var s1 = _s1;
      var i1 = _i1;
      if (Curry._2(cmp, s1, s2) <= 0) {
        Belt_Array.setExn(dst, d, s1);
        var i1$1 = i1 + 1 | 0;
        if (i1$1 >= src1r) {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
        _d = d + 1 | 0;
        _s1 = Belt_Array.getExn(a, i1$1);
        _i1 = i1$1;
        continue ;
      }
      Belt_Array.setExn(dst, d, s2);
      var i2$1 = i2 + 1 | 0;
      if (i2$1 >= src2r) {
        return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
      }
      _d = d + 1 | 0;
      _s2 = Belt_Array.getExn(src2, i2$1);
      _i2 = i2$1;
      continue ;
    };
  };
  var isortto = function (srcofs, dst, dstofs, len) {
    for(var i = 0; i < len; ++i){
      var e = Belt_Array.getExn(a, srcofs + i | 0);
      var j = (dstofs + i | 0) - 1 | 0;
      while(j >= dstofs && Curry._2(cmp, Belt_Array.getExn(dst, j), e) > 0) {
        Belt_Array.setExn(dst, j + 1 | 0, Belt_Array.getExn(dst, j));
        j = j - 1 | 0;
      };
      Belt_Array.setExn(dst, j + 1 | 0, e);
    }
    
  };
  var sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    }
    var l1 = len / 2 | 0;
    var l2 = len - l1 | 0;
    sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
    sortto(srcofs, a, srcofs + l2 | 0, l1);
    return merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
  };
  var l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  }
  var l1 = l / 2 | 0;
  var l2 = l - l1 | 0;
  var t = make(l2, Belt_Array.getExn(a, 0));
  sortto(l1, t, 0, l2);
  sortto(0, a, l2, l1);
  return merge(l2, l1, t, 0, l2, a, 0);
}

function to_seq$1(a) {
  var aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */0;
    }
    var x = Belt_Array.getExn(a, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(a) {
  var aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */0;
    }
    var x = Belt_Array.getExn(a, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_rev_list(l) {
  if (!l) {
    return [];
  }
  var len = list_length(0, l);
  var a = make(len, l.hd);
  var _i = len - 2 | 0;
  var _param = l.tl;
  while(true) {
    var param = _param;
    var i = _i;
    if (!param) {
      return a;
    }
    Belt_Array.setExn(a, i, param.hd);
    _param = param.tl;
    _i = i - 1 | 0;
    continue ;
  };
}

function of_seq(i) {
  return of_rev_list(fold_left((function (acc, x) {
                    return {
                            hd: x,
                            tl: acc
                          };
                  }), /* [] */0, i));
}

var $$Array$1 = {
  B: undefined,
  Imported: Imported,
  length: length,
  get: get$1,
  set: set,
  make: make,
  create: create,
  Internals: Internals,
  init: init,
  copy: copy,
  append: append$1,
  sub: sub,
  fill: fill,
  blit: blit,
  iter: iter$2,
  iter2: iter2,
  map: map$2,
  map2: map2,
  iteri: iteri,
  mapi: mapi,
  to_list: to_list$1,
  list_length: list_length,
  of_list: of_list,
  fold_left: fold_left$1,
  fold_right: fold_right,
  exists: exists,
  for_all: for_all,
  for_all2: for_all2,
  exists2: exists2,
  mem: mem,
  memq: memq,
  Bottom: Bottom,
  sort: sort,
  cutoff: 5,
  stable_sort: stable_sort,
  fast_sort: stable_sort,
  to_seq: to_seq$1,
  to_seqi: to_seqi,
  of_rev_list: of_rev_list,
  of_seq: of_seq
};

function ok(v) {
  return {
          TAG: /* Ok */0,
          _0: v
        };
}

function error(e) {
  return {
          TAG: /* Error */1,
          _0: e
        };
}

function value$1(r, $$default) {
  if (r.TAG === /* Ok */0) {
    return r._0;
  } else {
    return $$default;
  }
}

function get_ok(v) {
  if (v.TAG === /* Ok */0) {
    return v._0;
  } else {
    return Pervasives.invalid_arg("result is Error _");
  }
}

function get_error(e) {
  if (e.TAG === /* Ok */0) {
    return Pervasives.invalid_arg("result is Ok _");
  } else {
    return e._0;
  }
}

function bind$1(r, f) {
  if (r.TAG === /* Ok */0) {
    return Curry._1(f, r._0);
  } else {
    return r;
  }
}

function join$1(r) {
  if (r.TAG === /* Ok */0) {
    return r._0;
  } else {
    return r;
  }
}

function map$3(f, v) {
  if (v.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(f, v._0)
          };
  } else {
    return v;
  }
}

function map_error(f, e) {
  if (e.TAG === /* Ok */0) {
    return e;
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._1(f, e._0)
          };
  }
}

function fold$1(ok, error, v) {
  if (v.TAG === /* Ok */0) {
    return Curry._1(ok, v._0);
  } else {
    return Curry._1(error, v._0);
  }
}

function iter$3(f, v) {
  if (v.TAG === /* Ok */0) {
    return Curry._1(f, v._0);
  }
  
}

function iter_error(f, e) {
  if (e.TAG === /* Ok */0) {
    return ;
  } else {
    return Curry._1(f, e._0);
  }
}

function is_ok(param) {
  if (param.TAG === /* Ok */0) {
    return true;
  } else {
    return false;
  }
}

function is_error(param) {
  if (param.TAG === /* Ok */0) {
    return false;
  } else {
    return true;
  }
}

function equal$1(ok, error, r0, r1) {
  if (r0.TAG === /* Ok */0) {
    if (r1.TAG === /* Ok */0) {
      return Curry._2(ok, r0._0, r1._0);
    } else {
      return false;
    }
  } else if (r1.TAG === /* Ok */0) {
    return false;
  } else {
    return Curry._2(error, r0._0, r1._0);
  }
}

function compare$1(ok, error, r0, r1) {
  if (r0.TAG === /* Ok */0) {
    if (r1.TAG === /* Ok */0) {
      return Curry._2(ok, r0._0, r1._0);
    } else {
      return -1;
    }
  } else if (r1.TAG === /* Ok */0) {
    return 1;
  } else {
    return Curry._2(error, r0._0, r1._0);
  }
}

function to_option(v) {
  if (v.TAG === /* Ok */0) {
    return Caml_option.some(v._0);
  }
  
}

function to_list$2(v) {
  if (v.TAG === /* Ok */0) {
    return {
            hd: v._0,
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

function to_seq$2(v) {
  if (v.TAG !== /* Ok */0) {
    return empty;
  }
  var partial_arg = v._0;
  return function (param) {
    return /* Cons */{
            _0: partial_arg,
            _1: empty
          };
  };
}

var Result = {
  ok: ok,
  error: error,
  value: value$1,
  get_ok: get_ok,
  get_error: get_error,
  bind: bind$1,
  join: join$1,
  map: map$3,
  map_error: map_error,
  fold: fold$1,
  iter: iter$3,
  iter_error: iter_error,
  is_ok: is_ok,
  is_error: is_error,
  equal: equal$1,
  compare: compare$1,
  to_option: to_option,
  to_list: to_list$2,
  to_seq: to_seq$2
};

var length$1 = Belt_List.length;

function hd(l) {
  return or_exn({
              RE_EXN_ID: "Failure",
              _1: "hd"
            }, Belt_List.head(l));
}

function tl(l) {
  return or_exn({
              RE_EXN_ID: "Failure",
              _1: "tl"
            }, Belt_List.tail(l));
}

var nth_opt = Belt_List.get;

function nth(l, n) {
  return or_exn({
              RE_EXN_ID: "Invalid_argument",
              _1: "List.nth"
            }, Belt_List.get(l, n));
}

var rev_append = Belt_List.reverseConcat;

var rev = Belt_List.reverse;

var init$1 = Belt_List.makeBy;

var flatten = Belt_List.flatten;

function map$4(f, l) {
  return Belt_List.map(l, f);
}

function mapi$1(f, l) {
  return Belt_List.mapWithIndex(l, f);
}

function rev_map(f, l) {
  return Belt_List.mapReverse(l, f);
}

function iter$4(f, l) {
  return Belt_List.forEach(l, f);
}

function iteri$1(f, l) {
  return Belt_List.forEachWithIndex(l, f);
}

function fold_left$2(f, accu, l) {
  return Belt_List.reduce(l, accu, f);
}

function fold_right$1(f, l, accu) {
  return Belt_List.reduceReverse(l, accu, (function (param, param$1) {
                return Curry._2(f, param$1, param);
              }));
}

function map2$1(f, l1, l2) {
  return Belt_List.zipBy(l1, l2, f);
}

function rev_map2(f, l1, l2) {
  return Belt_List.mapReverse2(l1, l2, f);
}

function iter2$1(f, l1, l2) {
  return Belt_List.forEach2(l1, l2, f);
}

function for_all$1(p, l) {
  return Belt_List.every(l, p);
}

function exists$1(p, l) {
  return Belt_List.some(l, p);
}

function for_all2$1(p, l1, l2) {
  return Belt_List.every2(l1, l2, p);
}

function exists2$1(p, l1, l2) {
  return Belt_List.some2(l1, l2, p);
}

function mem$1(x, l) {
  return Belt_List.some(l, (function (param) {
                return Caml_obj.caml_equal(x, param);
              }));
}

function memq$1(x, l) {
  return Belt_List.some(l, (function (param) {
                return x === param;
              }));
}

function assoc_opt(k, l) {
  return Belt_List.getAssoc(l, k, Caml_obj.caml_equal);
}

function assq_opt(k, l) {
  return Belt_List.getAssoc(l, k, (function (prim0, prim1) {
                return prim0 === prim1;
              }));
}

function assoc(k, l) {
  var o = assoc_opt(k, l);
  return or_exn({
              RE_EXN_ID: "Not_found"
            }, o);
}

function assq(k, l) {
  var o = assq_opt(k, l);
  return or_exn({
              RE_EXN_ID: "Not_found"
            }, o);
}

function mem_assoc(x, l) {
  return Belt_List.hasAssoc(l, x, Caml_obj.caml_equal);
}

function mem_assq(x, l) {
  return Belt_List.hasAssoc(l, x, (function (prim0, prim1) {
                return prim0 === prim1;
              }));
}

function remove_assoc(x, l) {
  return Belt_List.removeAssoc(l, x, Caml_obj.caml_equal);
}

function remove_assq(x, l) {
  return Belt_List.removeAssoc(l, x, (function (prim0, prim1) {
                return prim0 === prim1;
              }));
}

function find_opt(p, l) {
  return Belt_List.getBy(l, p);
}

function find(p, l) {
  var o = Belt_List.getBy(l, p);
  return or_exn({
              RE_EXN_ID: "Not_found"
            }, o);
}

function find_map(f, l) {
  return bind(Belt_List.getBy(l, (function (x) {
                    return Curry._1(f, x) !== undefined;
                  })), f);
}

function find_all(p, l) {
  return Belt_List.keep(l, p);
}

function filteri(p, l) {
  return Belt_List.keepWithIndex(l, (function (param, param$1) {
                return Curry._2(p, param$1, param);
              }));
}

function filter_map$1(f, l) {
  return Belt_List.keepMap(l, f);
}

function concat_map(f, l) {
  var _acc = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var acc = _acc;
    if (!param) {
      return Belt_List.reverse(acc);
    }
    var xs = Curry._1(f, param.hd);
    _param = param.tl;
    _acc = Belt_List.reverseConcat(xs, acc);
    continue ;
  };
}

function fold_left_map(f, accu, l) {
  var _accu = accu;
  var _l_accu = /* [] */0;
  var _param = l;
  while(true) {
    var param = _param;
    var l_accu = _l_accu;
    var accu$1 = _accu;
    if (!param) {
      return [
              accu$1,
              Belt_List.reverse(l_accu)
            ];
    }
    var match = Curry._2(f, accu$1, param.hd);
    _param = param.tl;
    _l_accu = {
      hd: match[1],
      tl: l_accu
    };
    _accu = match[0];
    continue ;
  };
}

function partition(p, l) {
  return Belt_List.partition(l, p);
}

var split = Belt_List.unzip;

var combine = Belt_List.zip;

function merge(cmp, l1, l2) {
  if (!l1) {
    return l2;
  }
  if (!l2) {
    return l1;
  }
  var h2 = l2.hd;
  var h1 = l1.hd;
  if (Curry._2(cmp, h1, h2) <= 0) {
    return {
            hd: h1,
            tl: merge(cmp, l1.tl, l2)
          };
  } else {
    return {
            hd: h2,
            tl: merge(cmp, l1, l2.tl)
          };
  }
}

function stable_sort$1(cmp, l) {
  return Belt_List.sort(l, cmp);
}

function compare$2(cmp, l1, l2) {
  return Belt_List.cmp(l1, l2, cmp);
}

function equal$2(eq, l1, l2) {
  return Belt_List.eq(l1, l2, eq);
}

function to_seq$3(l) {
  var aux = function (l, param) {
    if (!l) {
      return /* Nil */0;
    }
    var tail = l.tl;
    return /* Cons */{
            _0: l.hd,
            _1: (function (param) {
                return aux(tail, param);
              })
          };
  };
  return function (param) {
    return aux(l, param);
  };
}

function of_seq$1(seq) {
  var direct = function (depth, seq) {
    if (depth === 0) {
      return Belt_List.reverse(fold_left((function (acc, x) {
                        return {
                                hd: x,
                                tl: acc
                              };
                      }), /* [] */0, seq));
    }
    var match = Curry._1(seq, undefined);
    if (match) {
      return {
              hd: match._0,
              tl: direct(depth - 1 | 0, match._1)
            };
    } else {
      return /* [] */0;
    }
  };
  return direct(500, seq);
}

var List = {
  B: undefined,
  length: length$1,
  hd: hd,
  tl: tl,
  nth_opt: nth_opt,
  nth: nth,
  append: Pervasives.$at,
  rev_append: rev_append,
  rev: rev,
  init: init$1,
  flatten: flatten,
  concat: flatten,
  map: map$4,
  mapi: mapi$1,
  rev_map: rev_map,
  iter: iter$4,
  iteri: iteri$1,
  fold_left: fold_left$2,
  fold_right: fold_right$1,
  map2: map2$1,
  rev_map2: rev_map2,
  iter2: iter2$1,
  for_all: for_all$1,
  exists: exists$1,
  for_all2: for_all2$1,
  exists2: exists2$1,
  mem: mem$1,
  memq: memq$1,
  assoc_opt: assoc_opt,
  assq_opt: assq_opt,
  assoc: assoc,
  assq: assq,
  mem_assoc: mem_assoc,
  mem_assq: mem_assq,
  remove_assoc: remove_assoc,
  remove_assq: remove_assq,
  find_opt: find_opt,
  find: find,
  find_map: find_map,
  find_all: find_all,
  filter: find_all,
  filteri: filteri,
  filter_map: filter_map$1,
  concat_map: concat_map,
  fold_left_map: fold_left_map,
  partition: partition,
  split: split,
  combine: combine,
  merge: merge,
  stable_sort: stable_sort$1,
  sort: stable_sort$1,
  fast_sort: stable_sort$1,
  compare: compare$2,
  equal: equal$2,
  to_seq: to_seq$3,
  of_seq: of_seq$1
};

function add_seq(tbl, i) {
  return iter((function (param) {
                return Hashtbl.add(tbl, param[0], param[1]);
              }), i);
}

function replace_seq(tbl, i) {
  return iter((function (param) {
                return Hashtbl.replace(tbl, param[0], param[1]);
              }), i);
}

function of_seq$2(i) {
  var tbl = Hashtbl.create(undefined, 16);
  replace_seq(tbl, i);
  return tbl;
}

function to_seq$4(tbl) {
  return to_seq$3(Hashtbl.fold((function (k, v, acc) {
                    return {
                            hd: [
                              k,
                              v
                            ],
                            tl: acc
                          };
                  }), tbl, /* [] */0));
}

function to_seq_keys(m) {
  var partial_arg = to_seq$4(m);
  return function (param) {
    return map((function (prim) {
                  return prim[0];
                }), partial_arg, param);
  };
}

function to_seq_values(m) {
  var partial_arg = to_seq$4(m);
  return function (param) {
    return map((function (prim) {
                  return prim[1];
                }), partial_arg, param);
  };
}

var Hashtbl$1 = {
  create: Hashtbl.create,
  clear: Hashtbl.clear,
  reset: Hashtbl.reset,
  copy: Hashtbl.copy,
  add: Hashtbl.add,
  find: Hashtbl.find,
  find_opt: Hashtbl.find_opt,
  find_all: Hashtbl.find_all,
  mem: Hashtbl.mem,
  remove: Hashtbl.remove,
  replace: Hashtbl.replace,
  iter: Hashtbl.iter,
  filter_map_inplace: Hashtbl.filter_map_inplace,
  fold: Hashtbl.fold,
  length: Hashtbl.length,
  randomize: Hashtbl.randomize,
  is_randomized: Hashtbl.is_randomized,
  stats: Hashtbl.stats,
  Make: Hashtbl.Make,
  MakeSeeded: Hashtbl.MakeSeeded,
  hash: Hashtbl.hash,
  seeded_hash: Hashtbl.seeded_hash,
  hash_param: Hashtbl.hash_param,
  seeded_hash_param: Hashtbl.seeded_hash_param,
  add_seq: add_seq,
  replace_seq: replace_seq,
  of_seq: of_seq$2,
  to_seq: to_seq$4,
  to_seq_keys: to_seq_keys,
  to_seq_values: to_seq_values
};

var get_uint8 = Caml_bytes.get;

function to_seq$5(s) {
  var aux = function (i, param) {
    if (i === s.length) {
      return /* Nil */0;
    }
    var x = Caml_bytes.get(s, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi$1(s) {
  var aux = function (i, param) {
    if (i === s.length) {
      return /* Nil */0;
    }
    var x = Caml_bytes.get(s, i);
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_seq$3(i) {
  var n = {
    contents: 0
  };
  var buf = {
    contents: Bytes.make(256, /* '\000' */0)
  };
  var resize = function (param) {
    var new_len = Caml.caml_int_min((buf.contents.length << 1), Sys.max_string_length);
    if (buf.contents.length === new_len) {
      Pervasives.failwith("Bytes.of_seq: cannot grow bytes");
    }
    var new_buf = Bytes.make(new_len, /* '\000' */0);
    Bytes.blit(buf.contents, 0, new_buf, 0, n.contents);
    buf.contents = new_buf;
    
  };
  iter((function (c) {
          if (n.contents === buf.contents.length) {
            resize(undefined);
          }
          Caml_bytes.set(buf.contents, n.contents, c);
          n.contents = n.contents + 1 | 0;
          
        }), i);
  return Bytes.sub(buf.contents, 0, n.contents);
}

var Bytes$1 = {
  make: Bytes.make,
  init: Bytes.init,
  empty: Bytes.empty,
  copy: Bytes.copy,
  of_string: Bytes.of_string,
  to_string: Bytes.to_string,
  sub: Bytes.sub,
  sub_string: Bytes.sub_string,
  extend: Bytes.extend,
  fill: Bytes.fill,
  blit: Bytes.blit,
  blit_string: Bytes.blit_string,
  concat: Bytes.concat,
  cat: Bytes.cat,
  iter: Bytes.iter,
  iteri: Bytes.iteri,
  map: Bytes.map,
  mapi: Bytes.mapi,
  trim: Bytes.trim,
  escaped: Bytes.escaped,
  index: Bytes.index,
  index_opt: Bytes.index_opt,
  rindex: Bytes.rindex,
  rindex_opt: Bytes.rindex_opt,
  index_from: Bytes.index_from,
  index_from_opt: Bytes.index_from_opt,
  rindex_from: Bytes.rindex_from,
  rindex_from_opt: Bytes.rindex_from_opt,
  contains: Bytes.contains,
  contains_from: Bytes.contains_from,
  rcontains_from: Bytes.rcontains_from,
  uppercase: Bytes.uppercase,
  lowercase: Bytes.lowercase,
  capitalize: Bytes.capitalize,
  uncapitalize: Bytes.uncapitalize,
  uppercase_ascii: Bytes.uppercase_ascii,
  lowercase_ascii: Bytes.lowercase_ascii,
  capitalize_ascii: Bytes.capitalize_ascii,
  uncapitalize_ascii: Bytes.uncapitalize_ascii,
  compare: Bytes.compare,
  equal: Bytes.equal,
  unsafe_to_string: Bytes.unsafe_to_string,
  unsafe_of_string: Bytes.unsafe_of_string,
  get_uint8: get_uint8,
  to_seq: to_seq$5,
  to_seqi: to_seqi$1,
  of_seq: of_seq$3
};

function to_seq$6(s) {
  return to_seq$5(Bytes.unsafe_of_string(s));
}

function to_seqi$2(s) {
  return to_seqi$1(Bytes.unsafe_of_string(s));
}

function of_seq$4(g) {
  return Bytes.unsafe_to_string(of_seq$3(g));
}

var $$String$1 = {
  make: $$String.make,
  init: $$String.init,
  sub: $$String.sub,
  blit: $$String.blit,
  concat: $$String.concat,
  iter: $$String.iter,
  iteri: $$String.iteri,
  map: $$String.map,
  mapi: $$String.mapi,
  trim: $$String.trim,
  escaped: $$String.escaped,
  index: $$String.index,
  index_opt: $$String.index_opt,
  rindex: $$String.rindex,
  rindex_opt: $$String.rindex_opt,
  index_from: $$String.index_from,
  index_from_opt: $$String.index_from_opt,
  rindex_from: $$String.rindex_from,
  rindex_from_opt: $$String.rindex_from_opt,
  contains: $$String.contains,
  contains_from: $$String.contains_from,
  rcontains_from: $$String.rcontains_from,
  uppercase: $$String.uppercase,
  lowercase: $$String.lowercase,
  capitalize: $$String.capitalize,
  uncapitalize: $$String.uncapitalize,
  uppercase_ascii: $$String.uppercase_ascii,
  lowercase_ascii: $$String.lowercase_ascii,
  capitalize_ascii: $$String.capitalize_ascii,
  uncapitalize_ascii: $$String.uncapitalize_ascii,
  compare: $$String.compare,
  equal: $$String.equal,
  split_on_char: $$String.split_on_char,
  B: undefined,
  bos: Bytes.unsafe_of_string,
  bts: Bytes.unsafe_to_string,
  to_seq: to_seq$6,
  to_seqi: to_seqi$2,
  of_seq: of_seq$4
};

function neg(x) {
  return -x | 0;
}

function add(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function sub$1(prim0, prim1) {
  return prim0 - prim1 | 0;
}

function mul(prim0, prim1) {
  return Math.imul(prim0, prim1);
}

var div = Caml_int32.div;

var rem = Caml_int32.mod_;

function succ(prim) {
  return prim + 1 | 0;
}

function pred(prim) {
  return prim - 1 | 0;
}

function abs(x) {
  if (x >= 0) {
    return x;
  } else {
    return -x | 0;
  }
}

var Imported$1 = {};

var max_int = Number.MAX_SAFE_INTEGER;

var min_int = Number.MIN_SAFE_INTEGER;

var Int = {
  zero: 0,
  one: 1,
  minus_one: -1,
  neg: neg,
  add: add,
  sub: sub$1,
  mul: mul,
  div: div,
  rem: rem,
  succ: succ,
  pred: pred,
  abs: abs,
  Imported: Imported$1,
  max_int: max_int,
  min_int: min_int
};

var Imported$2 = {};

function ceil(prim) {
  return Math.ceil(prim);
}

function floor(prim) {
  return Math.floor(prim);
}

function is_integer(prim) {
  return Number.isInteger(prim);
}

function to_int(x) {
  return x;
}

var Float = {
  Imported: Imported$2,
  ceil: ceil,
  floor: floor,
  is_integer: is_integer,
  to_int: to_int
};

function create$1(n) {
  var n$1 = n < 1 ? 1 : n;
  var n$2 = n$1 > Sys.max_string_length ? Sys.max_string_length : n$1;
  var s = Caml_bytes.caml_create_bytes(n$2);
  return {
          buffer: s,
          position: 0,
          length: n$2,
          initial_buffer: s
        };
}

function contents(b) {
  return Bytes.sub_string(b.buffer, 0, b.position);
}

function to_bytes(b) {
  return Bytes.sub(b.buffer, 0, b.position);
}

function sub$2(b, ofs, len) {
  if (ofs < 0 || len < 0 || ofs > (b.position - len | 0)) {
    return Pervasives.invalid_arg("Buffer.sub");
  } else {
    return Bytes.sub_string(b.buffer, ofs, len);
  }
}

function blit$1(src, srcoff, dst, dstoff, len) {
  if (len < 0 || srcoff < 0 || srcoff > (src.position - len | 0) || dstoff < 0 || dstoff > (dst.length - len | 0)) {
    return Pervasives.invalid_arg("Buffer.blit");
  } else {
    return Caml_bytes.caml_blit_bytes(src.buffer, srcoff, dst, dstoff, len);
  }
}

function nth$1(b, ofs) {
  if (ofs < 0 || ofs >= b.position) {
    return Pervasives.invalid_arg("Buffer.nth");
  } else {
    return b.buffer[ofs];
  }
}

function length$2(b) {
  return b.position;
}

function clear(b) {
  b.position = 0;
  
}

function reset(b) {
  b.position = 0;
  b.buffer = b.initial_buffer;
  b.length = b.buffer.length;
  
}

function resize(b, more) {
  var old_pos = b.position;
  var old_len = b.length;
  var new_len = old_len;
  while((old_pos + more | 0) > new_len) {
    new_len = (new_len << 1);
  };
  if (new_len > Sys.max_string_length) {
    if ((old_pos + more | 0) <= Sys.max_string_length) {
      new_len = Sys.max_string_length;
    } else {
      Pervasives.failwith("Buffer.add: cannot grow buffer");
    }
  }
  var new_buffer = Caml_bytes.caml_create_bytes(new_len);
  Bytes.blit(b.buffer, 0, new_buffer, 0, b.position);
  b.buffer = new_buffer;
  b.length = new_len;
  if ((b.position + more | 0) > b.length) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            803,
            2
          ],
          Error: new Error()
        };
  }
  if ((old_pos + more | 0) > b.length) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            804,
            2
          ],
          Error: new Error()
        };
  }
  
}

function add_char(b, c) {
  var pos = b.position;
  if (pos >= b.length) {
    resize(b, 1);
  }
  b.buffer[pos] = c;
  b.position = pos + 1 | 0;
  
}

function add_utf_8_uchar(b, u) {
  var u$1 = Uchar.to_int(u);
  if (u$1 < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            848,
            19
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 127) {
    return add_char(b, u$1);
  }
  if (u$1 <= 2047) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = 192 | (u$1 >>> 6);
    b.buffer[pos + 1 | 0] = 128 | u$1 & 63;
    b.position = pos + 2 | 0;
    return ;
  }
  if (u$1 <= 65535) {
    var pos$1 = b.position;
    if ((pos$1 + 3 | 0) > b.length) {
      resize(b, 3);
    }
    b.buffer[pos$1] = 224 | (u$1 >>> 12);
    b.buffer[pos$1 + 1 | 0] = 128 | (u$1 >>> 6) & 63;
    b.buffer[pos$1 + 2 | 0] = 128 | u$1 & 63;
    b.position = pos$1 + 3 | 0;
    return ;
  }
  if (u$1 <= 1114111) {
    var pos$2 = b.position;
    if ((pos$2 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$2] = 240 | (u$1 >>> 18);
    b.buffer[pos$2 + 1 | 0] = 128 | (u$1 >>> 12) & 63;
    b.buffer[pos$2 + 2 | 0] = 128 | (u$1 >>> 6) & 63;
    b.buffer[pos$2 + 3 | 0] = 128 | u$1 & 63;
    b.position = pos$2 + 4 | 0;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "kxclib_comp_re.ml",
          881,
          8
        ],
        Error: new Error()
      };
}

function add_utf_16be_uchar(b, u) {
  var u$1 = Uchar.to_int(u);
  if (u$1 < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            884,
            19
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 65535) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = (u$1 >>> 8);
    b.buffer[pos + 1 | 0] = u$1 & 255;
    b.position = pos + 2 | 0;
    return ;
  }
  if (u$1 <= 1114111) {
    var u$p = u$1 - 65536 | 0;
    var hi = 55296 | (u$p >>> 10);
    var lo = 56320 | u$p & 1023;
    var pos$1 = b.position;
    if ((pos$1 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$1] = (hi >>> 8);
    b.buffer[pos$1 + 1 | 0] = hi & 255;
    b.buffer[pos$1 + 2 | 0] = (lo >>> 8);
    b.buffer[pos$1 + 3 | 0] = lo & 255;
    b.position = pos$1 + 4 | 0;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "kxclib_comp_re.ml",
          902,
          8
        ],
        Error: new Error()
      };
}

function add_utf_16le_uchar(b, u) {
  var u$1 = Uchar.to_int(u);
  if (u$1 < 0) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            905,
            19
          ],
          Error: new Error()
        };
  }
  if (u$1 <= 65535) {
    var pos = b.position;
    if ((pos + 2 | 0) > b.length) {
      resize(b, 2);
    }
    b.buffer[pos] = u$1 & 255;
    b.buffer[pos + 1 | 0] = (u$1 >>> 8);
    b.position = pos + 2 | 0;
    return ;
  }
  if (u$1 <= 1114111) {
    var u$p = u$1 - 65536 | 0;
    var hi = 55296 | (u$p >>> 10);
    var lo = 56320 | u$p & 1023;
    var pos$1 = b.position;
    if ((pos$1 + 4 | 0) > b.length) {
      resize(b, 4);
    }
    b.buffer[pos$1] = hi & 255;
    b.buffer[pos$1 + 1 | 0] = (hi >>> 8);
    b.buffer[pos$1 + 2 | 0] = lo & 255;
    b.buffer[pos$1 + 3 | 0] = (lo >>> 8);
    b.position = pos$1 + 4 | 0;
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "kxclib_comp_re.ml",
          923,
          8
        ],
        Error: new Error()
      };
}

function add_substring(b, s, offset, len) {
  if (offset < 0 || len < 0 || offset > (s.length - len | 0)) {
    Pervasives.invalid_arg("Buffer.add_substring/add_subbytes");
  }
  var new_position = b.position + len | 0;
  if (new_position > b.length) {
    resize(b, len);
  }
  Caml_bytes.caml_blit_bytes(Bytes.of_string(s), offset, b.buffer, b.position, len);
  b.position = new_position;
  
}

function add_subbytes(b, s, offset, len) {
  return add_substring(b, Bytes.unsafe_to_string(s), offset, len);
}

function add_string(b, s) {
  var len = s.length;
  var new_position = b.position + len | 0;
  if (new_position > b.length) {
    resize(b, len);
  }
  Caml_bytes.caml_blit_bytes(Bytes.of_string(s), 0, b.buffer, b.position, len);
  b.position = new_position;
  
}

function add_bytes(b, s) {
  return add_string(b, Bytes.unsafe_to_string(s));
}

function add_buffer(b, bs) {
  return add_subbytes(b, bs.buffer, 0, bs.position);
}

function really_input_up_to(ic, buf, ofs, len) {
  var _already_read = 0;
  var _ofs = ofs;
  var _to_read = len;
  while(true) {
    var to_read = _to_read;
    var ofs$1 = _ofs;
    var already_read = _already_read;
    if (to_read === 0) {
      return already_read;
    }
    var r = Pervasives.input(ic, buf, ofs$1, to_read);
    if (r === 0) {
      return already_read;
    }
    var already_read$1 = already_read + r | 0;
    var ofs$2 = ofs$1 + r | 0;
    var to_read$1 = to_read - r | 0;
    _to_read = to_read$1;
    _ofs = ofs$2;
    _already_read = already_read$1;
    continue ;
  };
}

function unsafe_add_channel_up_to(b, ic, len) {
  if ((b.position + len | 0) > b.length) {
    resize(b, len);
  }
  var n = really_input_up_to(ic, b.buffer, b.position, len);
  if ((b.position + n | 0) > b.length) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "kxclib_comp_re.ml",
            973,
            2
          ],
          Error: new Error()
        };
  }
  b.position = b.position + n | 0;
  return n;
}

function add_channel(b, ic, len) {
  if (len < 0 || len > Sys.max_string_length) {
    Pervasives.invalid_arg("Buffer.add_channel");
  }
  var n = unsafe_add_channel_up_to(b, ic, len);
  if (n < len) {
    throw {
          RE_EXN_ID: "End_of_file",
          Error: new Error()
        };
  }
  
}

function output_buffer(oc, b) {
  return Pervasives.output(oc, b.buffer, 0, b.position);
}

function closing(param) {
  if (param === 40) {
    return /* ')' */41;
  }
  if (param === 123) {
    return /* '}' */125;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "kxclib_comp_re.ml",
          992,
          9
        ],
        Error: new Error()
      };
}

function advance_to_closing(opening, closing, k, s, start) {
  var _k = k;
  var _i = start;
  var lim = s.length;
  while(true) {
    var i = _i;
    var k$1 = _k;
    if (i >= lim) {
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
    }
    if (Caml_string.get(s, i) === opening) {
      _i = i + 1 | 0;
      _k = k$1 + 1 | 0;
      continue ;
    }
    if (Caml_string.get(s, i) === closing) {
      if (k$1 === 0) {
        return i;
      }
      _i = i + 1 | 0;
      _k = k$1 - 1 | 0;
      continue ;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function advance_to_non_alpha(s, start) {
  var _i = start;
  var lim = s.length;
  while(true) {
    var i = _i;
    if (i >= lim) {
      return lim;
    }
    var match = Caml_string.get(s, i);
    if (match >= 91) {
      if (match >= 97) {
        if (match >= 123) {
          return i;
        }
        
      } else if (match !== 95) {
        return i;
      }
      
    } else if (match >= 58) {
      if (match < 65) {
        return i;
      }
      
    } else if (match < 48) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_ident(s, start, lim) {
  if (start >= lim) {
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  var c = Caml_string.get(s, start);
  if (c !== 40 && c !== 123) {
    var stop = advance_to_non_alpha(s, start + 1 | 0);
    return [
            $$String.sub(s, start, stop - start | 0),
            stop
          ];
  }
  var new_start = start + 1 | 0;
  var stop$1 = advance_to_closing(c, closing(c), 0, s, new_start);
  return [
          $$String.sub(s, new_start, (stop$1 - start | 0) - 1 | 0),
          stop$1 + 1 | 0
        ];
}

function add_substitute(b, f, s) {
  var lim = s.length;
  var _previous = /* ' ' */32;
  var _i = 0;
  while(true) {
    var i = _i;
    var previous = _previous;
    if (i >= lim) {
      if (previous === /* '\\' */92) {
        return add_char(b, previous);
      } else {
        return ;
      }
    }
    var current = Caml_string.get(s, i);
    if (current !== 36) {
      if (previous === /* '\\' */92) {
        add_char(b, /* '\\' */92);
        add_char(b, current);
        _i = i + 1 | 0;
        _previous = /* ' ' */32;
        continue ;
      }
      if (current !== 92) {
        add_char(b, current);
        _i = i + 1 | 0;
        _previous = current;
        continue ;
      }
      _i = i + 1 | 0;
      _previous = current;
      continue ;
    }
    if (previous === /* '\\' */92) {
      add_char(b, current);
      _i = i + 1 | 0;
      _previous = /* ' ' */32;
      continue ;
    }
    var j = i + 1 | 0;
    var match = find_ident(s, j, lim);
    add_string(b, Curry._1(f, match[0]));
    _i = match[1];
    _previous = /* ' ' */32;
    continue ;
  };
}

function truncate(b, len) {
  if (len < 0 || len > b.position) {
    return Pervasives.invalid_arg("Buffer.truncate");
  } else {
    b.position = len;
    return ;
  }
}

function to_seq$7(b) {
  var aux = function (i, param) {
    if (i >= b.position) {
      return /* Nil */0;
    }
    var x = b.buffer[i];
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi$3(b) {
  var aux = function (i, param) {
    if (i >= b.position) {
      return /* Nil */0;
    }
    var x = b.buffer[i];
    var partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function add_seq$1(b, seq) {
  return iter((function (param) {
                return add_char(b, param);
              }), seq);
}

function of_seq$5(i) {
  var b = create$1(32);
  iter((function (param) {
          return add_char(b, param);
        }), i);
  return b;
}

function add_int8(b, x) {
  var new_position = b.position + 1 | 0;
  if (new_position > b.length) {
    resize(b, 1);
  }
  b.buffer[b.position] = x;
  b.position = new_position;
  
}

var $$Buffer = {
  create: create$1,
  contents: contents,
  to_bytes: to_bytes,
  sub: sub$2,
  blit: blit$1,
  nth: nth$1,
  length: length$2,
  clear: clear,
  reset: reset,
  resize: resize,
  add_char: add_char,
  add_utf_8_uchar: add_utf_8_uchar,
  add_utf_16be_uchar: add_utf_16be_uchar,
  add_utf_16le_uchar: add_utf_16le_uchar,
  add_substring: add_substring,
  add_subbytes: add_subbytes,
  add_string: add_string,
  add_bytes: add_bytes,
  add_buffer: add_buffer,
  really_input_up_to: really_input_up_to,
  unsafe_add_channel_up_to: unsafe_add_channel_up_to,
  add_channel: add_channel,
  output_buffer: output_buffer,
  closing: closing,
  advance_to_closing: advance_to_closing,
  advance_to_non_alpha: advance_to_non_alpha,
  find_ident: find_ident,
  add_substitute: add_substitute,
  truncate: truncate,
  to_seq: to_seq$7,
  to_seqi: to_seqi$3,
  add_seq: add_seq$1,
  of_seq: of_seq$5,
  add_int8: add_int8,
  add_uint8: add_int8
};

function to_xjv(param) {
  if (typeof param !== "object") {
    return null;
  }
  var variant = param.NAME;
  if (variant === "arr") {
    return map$2(to_xjv, of_list(param.VAL));
  }
  if (variant === "num") {
    return param.VAL;
  }
  if (variant !== "obj") {
    return param.VAL;
  }
  var o = {};
  Belt_List.forEach(param.VAL, (function (param) {
          return _obj_set(o, param[0], to_xjv(param[1]));
        }));
  return o;
}

function of_xjv(x) {
  var x$1 = Js_types.classify(x);
  if (typeof x$1 === "number") {
    switch (x$1) {
      case /* JSFalse */0 :
          return {
                  NAME: "bool",
                  VAL: false
                };
      case /* JSTrue */1 :
          return {
                  NAME: "bool",
                  VAL: true
                };
      case /* JSNull */2 :
          return "null";
      case /* JSUndefined */3 :
          return Pervasives.invalid_arg("of_xjv: 'undefined' not expected");
      
    }
  } else {
    switch (x$1.TAG | 0) {
      case /* JSNumber */0 :
          return {
                  NAME: "num",
                  VAL: x$1._0
                };
      case /* JSString */1 :
          return {
                  NAME: "str",
                  VAL: x$1._0
                };
      case /* JSObject */3 :
          var obj = x$1._0;
          if (Array.isArray(obj)) {
            var xs = to_list$1(map$2(of_xjv, obj));
            return {
                    NAME: "arr",
                    VAL: xs
                  };
          }
          var keys = Object.keys(obj);
          var fs = to_list$1(map$2((function (k) {
                      return [
                              k,
                              of_xjv(_obj_get(obj, k))
                            ];
                    }), keys));
          return {
                  NAME: "obj",
                  VAL: fs
                };
      case /* JSFunction */2 :
      case /* JSSymbol */4 :
          return Pervasives.invalid_arg("of_xjv: function not expected: " + _stringify(x$1._0));
      
    }
  }
}

function json_of_xjv(xjv) {
  return JSON.stringify(xjv);
}

function json_of_jv(jv) {
  return JSON.stringify(to_xjv(jv));
}

function xjv_of_json_exn(json) {
  return JSON.parse(json);
}

function xjv_of_json(json) {
  try {
    return Caml_option.some(JSON.parse(json));
  }
  catch (exn){
    return ;
  }
}

function jv_of_json_exn(json) {
  return of_xjv(JSON.parse(json));
}

function jv_of_json(json) {
  return map$1(of_xjv, xjv_of_json(json));
}

var obj00 = {
  NAME: "obj",
  VAL: /* [] */0
};

var obj01 = {
  NAME: "obj",
  VAL: {
    hd: [
      "name",
      {
        NAME: "str",
        VAL: "James Smith"
      }
    ],
    tl: {
      hd: [
        "age",
        {
          NAME: "num",
          VAL: 12
        }
      ],
      tl: /* [] */0
    }
  }
};

var obj02 = {
  NAME: "obj",
  VAL: {
    hd: [
      "name",
      {
        NAME: "str",
        VAL: "James Smith"
      }
    ],
    tl: {
      hd: [
        "age",
        {
          NAME: "num",
          VAL: 12
        }
      ],
      tl: {
        hd: [
          "spouse",
          "null"
        ],
        tl: {
          hd: [
            "parents",
            {
              NAME: "arr",
              VAL: {
                hd: {
                  NAME: "str",
                  VAL: "Amy Smith"
                },
                tl: {
                  hd: {
                    NAME: "str",
                    VAL: "Bob Smith"
                  },
                  tl: /* [] */0
                }
              }
            }
          ],
          tl: /* [] */0
        }
      }
    }
  }
};

var xjv_conv_obj00 = to_xjv(obj00);

var xjv_conv_obj01 = to_xjv(obj01);

var xjv_conv_obj02 = to_xjv(obj02);

var TestSamples = {
  obj00: obj00,
  obj01: obj01,
  obj02: obj02,
  xjv_conv_obj00: xjv_conv_obj00,
  xjv_conv_obj01: xjv_conv_obj01,
  xjv_conv_obj02: xjv_conv_obj02
};

var Json_ext = {
  to_xjv: to_xjv,
  of_xjv: of_xjv,
  json_of_xjv: json_of_xjv,
  json_of_jv: json_of_jv,
  xjv_of_json_exn: xjv_of_json_exn,
  xjv_of_json: xjv_of_json,
  jv_of_json_exn: jv_of_json_exn,
  jv_of_json: jv_of_json,
  TestSamples: TestSamples
};

function raw_backtrace_to_string(bt) {
  return $$String.concat("\n", bt);
}

function get_raw_backtrace(param) {
  var stacktrace = ((()=>{try { throw new Error();}catch(e){return e.stack}})());
  return $$String.split_on_char(/* '\n' */10, stacktrace);
}

var Printexc$1 = {
  to_string: Printexc.to_string,
  print: Printexc.print,
  $$catch: Printexc.$$catch,
  register_printer: Printexc.register_printer,
  raw_backtrace_to_string: raw_backtrace_to_string,
  get_raw_backtrace: get_raw_backtrace
};

var bytes0 = Bytes.init(12, Pervasives.char_of_int);

function bytes_of_uint8array(arr) {
  var len = arr.byteLength;
  return Bytes.init(len, (function (i) {
                return Pervasives.char_of_int(arr[i]);
              }));
}

function uint8array_of_bytes(bytes) {
  var len = bytes.length;
  var buf = new ArrayBuffer(len);
  var arr = new Uint8Array(buf);
  for(var i = 0; i < len; ++i){
    arr[i] = Caml_bytes.get(bytes, i);
  }
  return arr;
}

var JsInterop = {
  bytes0: bytes0,
  bytes_of_uint8array: bytes_of_uint8array,
  uint8array_of_bytes: uint8array_of_bytes
};

var Kxclib_comp_re = {
  BaseCompInternals: BaseCompInternals,
  Seq: Seq,
  $$Option: $$Option,
  $$Array: $$Array$1,
  Result: Result,
  List: List,
  Hashtbl: Hashtbl$1,
  Bytes: Bytes$1,
  $$String: $$String$1,
  Int: Int,
  Float: Float,
  $$Buffer: $$Buffer,
  Json_ext: Json_ext,
  Printexc: Printexc$1,
  JsInterop: JsInterop
};

var Kxclib_comp = {
  BaseCompInternals: BaseCompInternals,
  Seq: Seq,
  $$Option: $$Option,
  $$Array: $$Array$1,
  Result: Result,
  List: List,
  Hashtbl: Hashtbl$1,
  Bytes: Bytes$1,
  $$String: $$String$1,
  Int: Int,
  Float: Float,
  $$Buffer: $$Buffer,
  Json_ext: Json_ext,
  Printexc: Printexc$1,
  JsInterop: JsInterop
};

exports.Kxclib_comp_re = Kxclib_comp_re;
exports.Kxclib_comp = Kxclib_comp;
/* max_int Not a pure module */
